-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local client = LocalPlayer

-- Config
local active = true
local aimDuration = 1
local aimTargets = { "Slasher", "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true,
    ["71685573690338"] = true,
    ["111313169447787"] = true,
    ["134958187822107"] = true,
    ["77124578197357"] = true,
    ["90499469533503"] = true
}

local entanglementanimation = {
    ["119181003138006"] = true
}
local massinfectionanimation = {
    ["131430497821198"] = true
}

-- State
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local enaim = false
local massaim = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil

local Players = game:GetService("Players")

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not HRP then return nil end

    local nearest, nearestDist = nil, math.huge

    -- Check killers
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local humanoid = killer:FindFirstChildOfClass("Humanoid")
            local root = killer:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health > 0 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    -- Check players with 200+ HP
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health >= 200 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    return nearest
end


local function getValidSurvivor()
    local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    if not survivorFolder or not HRP then return nil end

    local nearest, nearestDist = nil, math.huge
    for _, survivor in ipairs(survivorFolder:GetChildren()) do
        local humanoid = survivor:FindFirstChildOfClass("Humanoid")
        local root = survivor:FindFirstChild("HumanoidRootPart")

        if humanoid and root and humanoid.Health > 0 then
            local dist = (root.Position - HRP.Position).Magnitude
            if dist < nearestDist then
                nearestDist = dist
                nearest = root
            end
        end
    end

    return nearest
end

local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then
                    ids[id] = true
                end
            end
        end
    end
    return ids
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    -- check entanglement animation
    local entanglementTriggered = false
    for id in pairs(entanglementanimation) do
        if playing[id] then
            entanglementTriggered = true
            break
        end
    end

    -- check mass infection animation
    local massinfectionTriggered = false
    for id in pairs(massinfectionanimation) do
        if playing[id] then
            massinfectionTriggered = true
            break
        end
    end

    -- normal tracked aimbot
    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end
    -- entanglement tracked aimbot
    if entanglementTriggered then
        lastTriggerTime = tick()
        enaim = true
    end
    -- massinfection tracked aimbot
    if massinfectionTriggered then
        lastTriggerTime = tick()
        massaim = true
    end

    -- helper function: yaw-only face target
    local function faceTarget(targetPos)
        local rootPos = HRP.Position
        local lookAt = CFrame.lookAt(rootPos, targetPos, Vector3.yAxis)

        -- Extract only yaw from lookAt
        local _, y, _ = lookAt:ToOrientation()
        HRP.CFrame = CFrame.new(rootPos) * CFrame.Angles(0, y, 0)
    end

-- ENTANGLEMENT AIMBOT (tracking survivors with projectile prediction)
if enaim and tick() - lastTriggerTime <= aimDuration then
    if not originalWS then
        originalWS = Humanoid.WalkSpeed
        originalJP = Humanoid.JumpPower
        originalAutoRotate = Humanoid.AutoRotate
    end

    Humanoid.AutoRotate = false
    HRP.AssemblyAngularVelocity = Vector3.zero

    local targetHRP = getValidSurvivor()
    if targetHRP then
        local targetPos = targetHRP.Position
        local targetVel = targetHRP.AssemblyLinearVelocity
        local projSpeed = 125 -- adjust projectile speed here

        local dist = (targetPos - HRP.Position).Magnitude
        local timeToHit = dist / projSpeed

        local predictedPos = targetPos + targetVel * timeToHit
        faceTarget(predictedPos)
    end
elseif enaim then
    enaim = false
    if originalWS and originalJP and originalAutoRotate ~= nil then
        Humanoid.WalkSpeed = originalWS
        Humanoid.JumpPower = originalJP
        Humanoid.AutoRotate = originalAutoRotate
        originalWS, originalJP, originalAutoRotate = nil, nil, nil
    end
end

-- MASS INFECTION AIMBOT (tracking survivors with projectile prediction)
if massaim and tick() - lastTriggerTime <= aimDuration then
    if not originalWS then
        originalWS = Humanoid.WalkSpeed
        originalJP = Humanoid.JumpPower
        originalAutoRotate = Humanoid.AutoRotate
    end

    Humanoid.AutoRotate = false
    HRP.AssemblyAngularVelocity = Vector3.zero

    local targetHRP = getValidSurvivor()
    if targetHRP then
        local targetPos = targetHRP.Position
        local targetVel = targetHRP.AssemblyLinearVelocity
        local projSpeed = 65.5 -- different projectile speed for this attack

        local dist = (targetPos - HRP.Position).Magnitude
        local timeToHit = dist / projSpeed

        local predictedPos = targetPos + targetVel * timeToHit
        faceTarget(predictedPos)
    end
elseif massaim then
    massaim = false
    if originalWS and originalJP and originalAutoRotate ~= nil then
        Humanoid.WalkSpeed = originalWS
        Humanoid.JumpPower = originalJP
        Humanoid.AutoRotate = originalAutoRotate
        originalWS, originalJP, originalAutoRotate = nil, nil, nil
    end
end

    -- NORMAL AIMBOT (tracking killers)
    if aiming and tick() - lastTriggerTime <= aimDuration then
        if not originalWS then
            originalWS = Humanoid.WalkSpeed
            originalJP = Humanoid.JumpPower
            originalAutoRotate = Humanoid.AutoRotate
        end

        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()

        if targetHRP then
            local vel = targetHRP.AssemblyLinearVelocity
            local predictedPos
            local reactionDelay = 0.2

            if vel.Magnitude > 0.4 then
                predictedPos = targetHRP.Position + vel * reactionDelay
            else
                predictedPos = targetHRP.Position
            end

            faceTarget(predictedPos)
        end
    elseif aiming then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
end)
