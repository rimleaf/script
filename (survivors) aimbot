-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local client = LocalPlayer

-- Config
local active = true
local aimDuration1 = 0.6 --WOW WHASHDO WOWOW 67 SIX SEVEEEEEEEEEEEEEEEEEEEN
local aimDuration2 = 0.15
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true,
    ["71685573690338"] = true,
    ["111313169447787"] = true,
    ["134958187822107"] = true,
    ["77124578197357"] = true,
    ["90499469533503"] = true
}

local entanglementanimation = {
    ["119181003138006"] = true
}

local massinfectionanimation = {
    ["131430497821198"] = true
}

-- State
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local enaim = false
local massaim = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil

--// Services
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--// Config
local BrightnessValue = 2
local TimeOfDayValue = "12:00:00" -- Noon
local FogEndValue = 1e6
local GlobalShadowsValue = false
local MaxZoomValue = 100 -- change this to whatever max zoom you want

--// Function to enforce lighting
local function enforceSettings()
    Lighting.Brightness = BrightnessValue
    Lighting.TimeOfDay = TimeOfDayValue
    Lighting.FogEnd = FogEndValue
    Lighting.GlobalShadows = GlobalShadowsValue

    -- If Atmosphere exists, override its settings too
    local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere then
        atmosphere.Haze = 0
        atmosphere.Density = 0
    end
end

--// Function to enforce zoom
local function enforceZoom()
    if LocalPlayer and LocalPlayer.CameraMaxZoomDistance ~= MaxZoomValue then
        LocalPlayer.CameraMaxZoomDistance = MaxZoomValue
    end
end

-- Initial enforcement
enforceSettings()
enforceZoom()

-- Keep lighting consistent
Lighting:GetPropertyChangedSignal("Brightness"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("TimeOfDay"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("FogEnd"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(enforceSettings)
Lighting.ChildAdded:Connect(function(child)
    if child:IsA("Atmosphere") then
        enforceSettings()
    end
end)

-- Keep zoom consistent
LocalPlayer:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(enforceZoom)


local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not HRP then return nil end

    local nearest, nearestDist = nil, math.huge

    -- Check killers
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local humanoid = killer:FindFirstChildOfClass("Humanoid")
            local root = killer:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health > 0 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    -- Check players with 200+ HP
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health >= 200 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    return nearest
end


local function getValidSurvivor()
    local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    if not survivorFolder or not HRP then return nil end

    local nearest, nearestDist = nil, math.huge
    for _, survivor in ipairs(survivorFolder:GetChildren()) do
        local humanoid = survivor:FindFirstChildOfClass("Humanoid")
        local root = survivor:FindFirstChild("HumanoidRootPart")

        if humanoid and root and humanoid.Health > 0 then
            local dist = (root.Position - HRP.Position).Magnitude
            if dist < nearestDist then
                nearestDist = dist
                nearest = root
            end
        end
    end

    return nearest
end

local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then
                    ids[id] = true
                end
            end
        end
    end
    return ids
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function isMoving(hrp)
    if not hrp then return false end
    return hrp.AssemblyLinearVelocity.Magnitude > 1
end

-- Predict position based on projectile speed and optionally add forgiveness
local function getPredictedPos(targetHRP, projSpeed, forgiveness, leadFactor)
    local dist = (targetHRP.Position - HRP.Position).Magnitude
    local travelTime = projSpeed > 0 and (dist / projSpeed) or 0
    local vel = targetHRP.AssemblyLinearVelocity

    local predictedPos
    if vel.Magnitude > 0.2 then
        leadFactor = leadFactor or 1.0
        predictedPos = targetHRP.Position + vel * travelTime * leadFactor
    else
        predictedPos = targetHRP.Position
    end

    if forgiveness and forgiveness > 0 then
        local dir = (predictedPos - HRP.Position)
        if dir.Magnitude > 0 then
            predictedPos = predictedPos + dir.Unit * forgiveness
        end
    end
    return predictedPos, dist
end

local function aimAt(pos)
    if not HRP then return end
    local dir = pos - HRP.Position
    if dir.Magnitude == 0 then return end
    local direction = dir.Unit
    local yRot = math.atan2(-direction.X, -direction.Z)
    HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
end

-- ENTANGLEMENT / MASS INFECTION AIM (search nearest alive player)
local function AimForDuration(duration, projSpeed, forgiveness, leadFactor)
    local start = tick()
    while tick() - start < duration do
        local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        local nearestHRP, nearestDist = nil, math.huge
        for _, survivor in ipairs(survivorFolder:GetChildren()) do
            local hum = survivor:FindFirstChildOfClass("Humanoid")
            local root = survivor:FindFirstChild("HumanoidRootPart")
            if hum and hum.Health > 0 and root and survivor ~= LocalPlayer.Character then
                local d = (root.Position - HRP.Position).Magnitude
                if d < nearestDist then
                    nearestDist = d
                    nearestHRP = root
                end
            end
        end

        if nearestHRP then
            local predictedPos = getPredictedPos(nearestHRP, projSpeed, forgiveness, leadFactor)
            aimAt(predictedPos)
        end

        RunService.Heartbeat:Wait()
    end
end

local entanglementTaskActive = false
local massInfectionTaskActive = false

RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    -- check entanglement animation
    local entanglementTriggered = false
    for id in pairs(entanglementanimation) do
        if playing[id] then
            entanglementTriggered = true
            break
        end
    end

    -- check mass infection animation
    local massinfectionTriggered = false
    for id in pairs(massinfectionanimation) do
        if playing[id] then
            massinfectionTriggered = true
            break
        end
    end

    -- normal tracked aimbot
    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end

    -- helper function: yaw-only face target
    local function faceTarget(targetPos)
        local rootPos = HRP.Position
        local lookAt = CFrame.lookAt(rootPos, targetPos, Vector3.yAxis)

        -- Extract only yaw from lookAt
        local _, y, _ = lookAt:ToOrientation()
        HRP.CFrame = CFrame.new(rootPos) * CFrame.Angles(0, y, 0)
    end

    -- ENTANGLEMENT AIMBOT (precise, no forgiveness, slight overshoot)
    if entanglementTriggered and not entanglementTaskActive then
        entanglementTaskActive = true
        task.spawn(function()
            AimForDuration(0.8, 120, 0, 1.50) -- 30% extra lead
            entanglementTaskActive = false
        end)
    end

    -- MASS INFECTION AIMBOT (slower proj, needs forgiveness, more overshoot)
    if massinfectionTriggered and not massInfectionTaskActive then
        massInfectionTaskActive = true
        task.spawn(function()
            AimForDuration(0.8, 60, 2, 1.50) -- 30% extra lead
            massInfectionTaskActive = false
        end)
    end

    -- NORMAL AIMBOT (tracking killers)
    if aiming and tick() - lastTriggerTime <= aimDuration1 then
        if not originalWS then
            originalWS = Humanoid.WalkSpeed
            originalJP = Humanoid.JumpPower
            originalAutoRotate = Humanoid.AutoRotate
        end

        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()

        if targetHRP then
            local vel = targetHRP.AssemblyLinearVelocity
            local predictedPos
            local reactionDelay = 0.2

            if vel.Magnitude > 0.1 then
                predictedPos = targetHRP.Position + vel * reactionDelay
            else
                predictedPos = targetHRP.Position
            end

            faceTarget(predictedPos)
        end
    elseif aiming then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
end)
