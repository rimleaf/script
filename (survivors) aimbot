
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--// Config
local BrightnessValue = 2
local TimeOfDayValue = "12:00:00" -- Noon
local FogEndValue = 1e6
local GlobalShadowsValue = false
local MaxZoomValue = 100 -- change this to whatever max zoom you want

--// Function to enforce lighting
local function enforceSettings()
    Lighting.Brightness = BrightnessValue
    Lighting.TimeOfDay = TimeOfDayValue
    Lighting.FogEnd = FogEndValue
    Lighting.GlobalShadows = GlobalShadowsValue

    -- If Atmosphere exists, override its settings too
    local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere then
        atmosphere.Haze = 0
        atmosphere.Density = 0
    end
end

--// Function to enforce zoom
local function enforceZoom()
    if LocalPlayer and LocalPlayer.CameraMaxZoomDistance ~= MaxZoomValue then
        LocalPlayer.CameraMaxZoomDistance = MaxZoomValue
    end
end

-- Initial enforcement
enforceSettings()
enforceZoom()

-- Keep lighting consistent
Lighting:GetPropertyChangedSignal("Brightness"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("TimeOfDay"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("FogEnd"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(enforceSettings)
Lighting.ChildAdded:Connect(function(child)
    if child:IsA("Atmosphere") then
        enforceSettings()
    end
end)

-- Keep zoom consistent
LocalPlayer:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(enforceZoom)

--// Services
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")

local LocalPlayer = Players.LocalPlayer

--// Config
local aimDuration = 1.7
local movementThreshold = 0.5 -- studs/sec
local aimTargets = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }

--// State
local Humanoid, HRP = nil, nil
local aiming = false
local lastTriggerTime = 0
local prevFlintVisible = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil
local predictionMode = "Velocity" -- or "Ping"

--// Helpers
local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart, target:FindFirstChild("Humanoid")
            end
        end
    end
    return nil, nil
end

local function getPingSeconds()
    local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then
        return pingStat:GetValue() / 1000
    end
    return 0.1
end

-- Velocity prediction
local function getPredictedAimPosVelocity(targetHRP)
    local prediction = 1 -- default value, can tweak
    if targetHRP.Velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    else
        return targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
    end
end

-- Ping prediction
local function getPredictedAimPosPing(targetHRP)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity

    if velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    end
    return targetHRP.Position + (velocity * ping)
end

-- Detect Flintlock visibility (trigger condition)
local function isFlintlockVisible()
    if not LocalPlayer.Character then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end

    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end

    return flint.Transparency < 1
end

--// Main Aimbot Loop
RunService.RenderStepped:Connect(function()
    if not Humanoid or not HRP then return end

    -- Rising edge detection (Flintlock appears)
    local isVisible = isFlintlockVisible()
    if isVisible and not prevFlintVisible and not aiming then
        lastTriggerTime = tick()
        aiming = true
    end
    prevFlintVisible = isVisible

    if aiming then
        local elapsed = tick() - lastTriggerTime

        if elapsed <= aimDuration then
            -- Save original states once
            if not originalWS then
                originalWS = Humanoid.WalkSpeed
                originalJP = Humanoid.JumpPower
                originalAutoRotate = Humanoid.AutoRotate
            end

            Humanoid.AutoRotate = false
            HRP.AssemblyAngularVelocity = Vector3.zero

            local targetHRP = getValidTarget()
            if targetHRP then
                local aimPos
                if predictionMode == "Ping" then
                    aimPos = getPredictedAimPosPing(targetHRP)
                else
                    aimPos = getPredictedAimPosVelocity(targetHRP)
                end

                if aimPos then
                    local direction = (aimPos - HRP.Position).Unit
                    local yRot = math.atan2(-direction.X, -direction.Z)
                    HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                end
            end
        else
            -- Reset after aim
            aiming = false
            if originalWS and originalJP and originalAutoRotate ~= nil then
                Humanoid.WalkSpeed = originalWS
                Humanoid.JumpPower = originalJP
                Humanoid.AutoRotate = originalAutoRotate
                originalWS, originalJP, originalAutoRotate = nil, nil, nil
            end
        end
    end
end)
