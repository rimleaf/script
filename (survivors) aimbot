--loadstring(game:HttpGet("https://raw.githubusercontent.com/skibidi399/Chance-aimbot/refs/heads/main/Chance%20aimbot%20v2"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/rimleaf/script/refs/heads/main/duhsekah"))()
wait(0.1)
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
--// Config
local MaxZoomValue = 100 -- change this to whatever max zoom you want
--// Function to enforce zoom
local function enforceZoom()
    if LocalPlayer and LocalPlayer.CameraMaxZoomDistance ~= MaxZoomValue then
        LocalPlayer.CameraMaxZoomDistance = MaxZoomValue
    end
end
enforceZoom()
-- Keep zoom consistent
LocalPlayer:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(enforceZoom)
wait(0.2)
-- Backstab Script (final style, cooldown-only Dagger)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
---------------------------------------------------------
-- GUI Setup
---------------------------------------------------------
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BackstabToggleGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = lp:WaitForChild("PlayerGui")
-- Main draggable frame (full UI)
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 180, 0, 150)
mainFrame.Position = UDim2.new(0, 10, 0, 10)
mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
mainFrame.BackgroundTransparency = 0.3
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
-- Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 150, 0, 40)
toggleButton.Position = UDim2.new(0, 15, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleButton.Font = Enum.Font.SourceSansBold
toggleButton.TextSize = 20
toggleButton.Text = "Backstab: OFF"
toggleButton.Parent = mainFrame
-- Range Label
local rangeLabel = Instance.new("TextLabel")
rangeLabel.Size = UDim2.new(0, 150, 0, 20)
rangeLabel.Position = UDim2.new(0, 15, 0, 55)
rangeLabel.BackgroundTransparency = 1
rangeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
rangeLabel.Font = Enum.Font.SourceSans
rangeLabel.TextSize = 16
rangeLabel.Text = "Range:"
rangeLabel.Parent = mainFrame
-- TextBox for Range Input
local rangeBox = Instance.new("TextBox")
rangeBox.Size = UDim2.new(0, 150, 0, 25)
rangeBox.Position = UDim2.new(0, 15, 0, 75)
rangeBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
rangeBox.TextColor3 = Color3.fromRGB(255, 255, 255)
rangeBox.Font = Enum.Font.SourceSans
rangeBox.TextSize = 16
rangeBox.PlaceholderText = "Enter range (1 - 10)"
rangeBox.Text = "4"
rangeBox.ClearTextOnFocus = false
rangeBox.Parent = mainFrame
-- Mode Toggle
local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 150, 0, 25)
modeButton.Position = UDim2.new(0, 15, 0, 105)
modeButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
modeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
modeButton.Font = Enum.Font.SourceSans
modeButton.TextSize = 16
modeButton.Text = "Mode: Behind"
modeButton.Parent = mainFrame
---------------------------------------------------------
-- Mini Toggle UI (draggable master toggle)
---------------------------------------------------------
local miniGui = Instance.new("ScreenGui")
miniGui.Name = "BackstabMiniToggle"
miniGui.ResetOnSpawn = false
miniGui.Parent = lp:WaitForChild("PlayerGui")
local miniFrame = Instance.new("Frame")
miniFrame.Size = UDim2.new(0, 120, 0, 35)
miniFrame.Position = UDim2.new(0, 200, 0, 10)
miniFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
miniFrame.Active = true
miniFrame.Draggable = false -- use custom dragging for mobile
miniFrame.Parent = miniGui
local miniButton = Instance.new("TextButton")
miniButton.Size = UDim2.new(1, 0, 1, 0)
miniButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
miniButton.TextColor3 = Color3.fromRGB(255, 255, 255)
miniButton.Font = Enum.Font.SourceSansBold
miniButton.TextSize = 16
miniButton.Text = "Hide UI"
miniButton.Parent = miniFrame
miniButton.Active = true -- allow input capture
-- Custom dragging variables for mobile and mouse
local dragInput, dragging, dragStart, startPos, dragMoved = nil, false, nil, nil, false
-- Helper to update position while dragging; simple clamp to screen bounds
local function clampPosition(offsetX, offsetY)
    local screenW = workspace.CurrentCamera.ViewportSize.X
    local screenH = workspace.CurrentCamera.ViewportSize.Y
    local newX = math.clamp(offsetX, 0, screenW - miniFrame.AbsoluteSize.X)
    local newY = math.clamp(offsetY, 0, screenH - miniFrame.AbsoluteSize.Y)
    return newX, newY
end
local function update(input)
    if not (dragStart and startPos) then return end
    local delta = input.Position - dragStart
    local newX = startPos.X.Offset + delta.X
    local newY = startPos.Y.Offset + delta.Y
    newX, newY = clampPosition(newX, newY)
    miniFrame.Position = UDim2.new(startPos.X.Scale, newX, startPos.Y.Scale, newY)
end
-- Input handlers for miniButton so dragging works on top of the button on mobile
miniButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = miniFrame.Position
        dragMoved = false
        -- When the input ends, stop dragging
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                dragInput = nil
                -- small delay to avoid accidental immediate click after drag
                task.wait(0.02)
            end
        end)
    end
end)
miniButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        -- detect small movement to block click events
        local delta = input.Position - (dragStart or input.Position)
        if math.abs(delta.X) > 4 or math.abs(delta.Y) > 4 then
            dragMoved = true
        end
        update(input)
    end
end)
miniButton.MouseButton1Click:Connect(function()
    -- if we just dragged, ignore the click so toggling doesn't fire accidentally
    if dragMoved then
        dragMoved = false
        return
    end
    mainFrame.Visible = not mainFrame.Visible
    miniButton.Text = mainFrame.Visible and "Hide UI" or "Show UI"
end)
---------------------------------------------------------
-- Logic + Dagger Handling
---------------------------------------------------------
local enabled = false
local cooldown = false
local lastTarget = nil
local range = 4
local mode = "Behind"
local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
-- State caches
local cachedPlayerGui = lp:FindFirstChild("PlayerGui")
local cachedDaggerBtn, cachedCooldown = nil, nil
-- Toggle backstab
toggleButton.MouseButton1Click:Connect(function()
	enabled = not enabled
	toggleButton.Text = "Backstab: " .. (enabled and "ON" or "OFF")
	toggleButton.BackgroundColor3 = enabled and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(30, 30, 30)
end)
-- Range input
rangeBox.FocusLost:Connect(function()
	local input = tonumber(rangeBox.Text)
	if input and input >= 1 and input <= 20 then
		range = input
	else
		rangeBox.Text = tostring(range)
	end
end)
-- Mode toggle
modeButton.MouseButton1Click:Connect(function()
	mode = (mode == "Behind") and "Around" or "Behind"
	modeButton.Text = "Mode: " .. mode
end)
---------------------------------------------------------
-- Helpers
---------------------------------------------------------
local function tryActivateButton(btn)
    if not btn then return false end
    pcall(function() btn:Activate() end)
    if type(getconnections) == "function" then
        for _, conn in ipairs(getconnections(btn.MouseButton1Click)) do
            pcall(function()
                if conn.Function then conn.Function()
                elseif conn.func then conn.func()
                elseif conn.Fire then conn.Fire() end
            end)
        end
    end
    return true
end
local function refreshUIRefs()
    cachedPlayerGui = lp:FindFirstChild("PlayerGui")
    local main = cachedPlayerGui and cachedPlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedDaggerBtn = ability and ability:FindFirstChild("Dagger")
        cachedCooldown = cachedDaggerBtn and cachedDaggerBtn:FindFirstChild("CooldownTime")
    else
        cachedDaggerBtn, cachedCooldown = nil, nil
    end
end
local function fireGuiDagger()
    if cachedDaggerBtn and tryActivateButton(cachedDaggerBtn) then return end
end
local function isDaggerReady()
    if not cachedDaggerBtn then return false end
    if cachedCooldown and cachedCooldown.Text ~= "" then return false end
    return true
end
local function isBehindTarget(hrp, targetHRP)
	local distance = (hrp.Position - targetHRP.Position).Magnitude
	if distance > range then return false end
	if mode == "Around" then return true end
	local direction = -targetHRP.CFrame.LookVector
	local toPlayer = (hrp.Position - targetHRP.Position)
	return toPlayer:Dot(direction) > 0.4
end
---------------------------------------------------------
-- Keep refs fresh
---------------------------------------------------------
refreshUIRefs()
if cachedPlayerGui then
    cachedPlayerGui.ChildAdded:Connect(function(child)
        if child.Name == "MainUI" then
            task.delay(0.1, refreshUIRefs)
        end
    end)
end
lp.CharacterAdded:Connect(function() task.delay(0.5, refreshUIRefs) end)
---------------------------------------------------------
-- Main Backstab Loop
---------------------------------------------------------
RunService.Heartbeat:Connect(function()
	if not enabled or not isDaggerReady() then return end
	local char = lp.Character
	if not (char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChildOfClass("Humanoid")) then return end
	local hrp = char.HumanoidRootPart
	local humanoid = char:FindFirstChildOfClass("Humanoid")

	for _, name in ipairs(killerNames) do
		local killer = killersFolder:FindFirstChild(name)
		if killer and killer:FindFirstChild("HumanoidRootPart") then
			local kHRP = killer.HumanoidRootPart
			if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
				cooldown, lastTarget = true, killer
				local start = tick()
				local didDagger = false
				local connection

				-- Disable auto-rotate before teleporting
				humanoid.AutoRotate = false

				connection = RunService.Heartbeat:Connect(function()
					if not (char and char.Parent and kHRP and kHRP.Parent) then
						if connection then connection:Disconnect() end
						-- Re-enable auto-rotate if something breaks early
						humanoid.AutoRotate = true
						return
					end
                    if not didDagger then
						didDagger = true
						if isDaggerReady() then
							fireGuiDagger()
						end
					end
					local elapsed = tick() - start
					if elapsed >= 0.55 then
						if connection then connection:Disconnect() end
						-- Re-enable auto-rotate once done teleporting
						humanoid.AutoRotate = true
						return
					end
					-- Constant TP behind killer
					local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 1.5)
					hrp.CFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)
				end)

				task.delay(2, function()
					RunService.Heartbeat:Wait()
					while isBehindTarget(hrp, kHRP) do
						RunService.Heartbeat:Wait()
					end
					lastTarget, cooldown = nil, false
					-- Ensure auto-rotate re-enables after sequence ends
					if humanoid then
						humanoid.AutoRotate = true
					end
				end)

				break
			end
		end
	end
end)

