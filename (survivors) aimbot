-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local client = LocalPlayer

-- Config
local active = true
local aimDuration = 1
local aimTargets = { "Slasher", "Jason", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true,
    ["71685573690338"] = true,
    ["111313169447787"] = true,
    ["134958187822107"] = true,
    ["77124578197357"] = true,
    ["90499469533503"] = true
}

local entanglementanimation = {
    ["119181003138006"] = true
}
local massinfectionanimation = {
    ["131430497821198"] = true
}

-- State
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local enaim = false
local massaim = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil

local Players = game:GetService("Players")

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not HRP then return nil end

    local nearest, nearestDist = nil, math.huge

    -- Check killers
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local humanoid = killer:FindFirstChildOfClass("Humanoid")
            local root = killer:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health > 0 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    -- Check players with 200+ HP
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health >= 200 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    return nearest
end


local function getValidSurvivor()
    local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    if not survivorFolder or not HRP then return nil end

    local nearest, nearestDist = nil, math.huge
    for _, survivor in ipairs(survivorFolder:GetChildren()) do
        local humanoid = survivor:FindFirstChildOfClass("Humanoid")
        local root = survivor:FindFirstChild("HumanoidRootPart")

        if humanoid and root and humanoid.Health > 0 then
            local dist = (root.Position - HRP.Position).Magnitude
            if dist < nearestDist then
                nearestDist = dist
                nearest = root
            end
        end
    end

    return nearest
end

local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then
                    ids[id] = true
                end
            end
        end
    end
    return ids
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    -- check entanglement animation
    local entanglementTriggered = false
    for id in pairs(entanglementanimation) do
        if playing[id] then
            entanglementTriggered = true
            break
        end
    end

    -- check mass infection animation
    local massinfectionTriggered = false
    for id in pairs(massinfectionanimation) do
        if playing[id] then
            massinfectionTriggered = true
            break
        end
    end

    -- normal tracked aimbot
    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end
    -- entanglement tracked aimbot
    if entanglementTriggered then
        lastTriggerTime = tick()
        enaim = true
    end
    -- massinfection tracked aimbot
    if massinfectionTriggered then
        lastTriggerTime = tick()
        massaim = true
    end

    -- helper function: yaw-only face target
    local function faceTarget(targetPos)
        local rootPos = HRP.Position
        local lookAt = CFrame.lookAt(rootPos, targetPos, Vector3.yAxis)

        -- Extract only yaw from lookAt
        local _, y, _ = lookAt:ToOrientation()
        HRP.CFrame = CFrame.new(rootPos) * CFrame.Angles(0, y, 0)
    end

-- helper utilities
local function clamp(val, low, high)
    if low and val < low then return low end
    if high and val > high then return high end
    return val
end

-- Predict target position using projectile speed + target velocity.
-- srcPos: Vector3 (your HRP position)
-- targetHRP: the target HumanoidRootPart (or part with Position & AssemblyLinearVelocity)
-- projSpeed: number > 0 (projectile studs/sec)
-- minTime/maxTime: clamps for timeToHit (seconds)
-- maxLead: maximum lead offset magnitude (studs)
local function predictPosition(targetHRP, srcPos, projSpeed, minTime, maxTime, maxLead)
    if not targetHRP then return nil end

    local targetPos = targetHRP.Position
    local targetVel = targetHRP.AssemblyLinearVelocity or Vector3.new(0,0,0)

    -- if target is basically standing still, aim at their current position
    if targetVel.Magnitude <= 0.4 then
        return targetPos
    end

    -- safe fallback if projSpeed isn't valid
    local timeToHit
    if projSpeed and projSpeed > 0 then
        local dist = (targetPos - srcPos).Magnitude
        timeToHit = dist / projSpeed
    else
        timeToHit = minTime or 0.35
    end

    -- clamp the time, so far targets don't create huge prediction
    timeToHit = clamp(timeToHit, minTime or 0.15, maxTime or 0.8)

    -- lead offset
    local leadOffset = targetVel * timeToHit

    -- clamp lead magnitude (so very fast players can't push it too far)
    if maxLead and maxLead > 0 and leadOffset.Magnitude > 0. then
        leadOffset = leadOffset.Unit * maxLead
    end

    return targetPos + leadOffset
end

-- ENTANGLEMENT AIMBOT (tracking survivors with distance + clamps)
if enaim and tick() - lastTriggerTime <= aimDuration then
    if not originalWS then
        originalWS = Humanoid.WalkSpeed
        originalJP = Humanoid.JumpPower
        originalAutoRotate = Humanoid.AutoRotate
    end

    Humanoid.AutoRotate = false
    HRP.AssemblyAngularVelocity = Vector3.zero

    local targetHRP = getValidSurvivor()
    if targetHRP then
        -- tuning: change these per-move to taste
        local projSpeed = 125           -- projectile speed in studs/sec for Entanglement
        local minTime = 0.12            -- minimum prediction time (s)
        local maxTime = 1            -- maximum prediction time (s)
        local maxLead  = 18             -- max lead offset in studs

        local predictedPos = predictPosition(targetHRP, HRP.Position, projSpeed, minTime, maxTime, maxLead)
        if predictedPos then
            faceTarget(predictedPos)
        end
    end
elseif enaim then
    enaim = false
    if originalWS and originalJP and originalAutoRotate ~= nil then
        Humanoid.WalkSpeed = originalWS
        Humanoid.JumpPower = originalJP
        Humanoid.AutoRotate = originalAutoRotate
        originalWS, originalJP, originalAutoRotate = nil, nil, nil
    end
end

-- MASS INFECTION AIMBOT (tracking survivors with distance + clamps)
if massaim and tick() - lastTriggerTime <= aimDuration then
    if not originalWS then
        originalWS = Humanoid.WalkSpeed
        originalJP = Humanoid.JumpPower
        originalAutoRotate = Humanoid.AutoRotate
    end

    Humanoid.AutoRotate = false
    HRP.AssemblyAngularVelocity = Vector3.zero

    local targetHRP = getValidSurvivor()
    if targetHRP then
        -- tuning: different projectile characteristics for Mass Infection
        local projSpeed = 67            -- projectile speed in studs/sec for Mass Infection
        local minTime = 0.10
        local maxTime = 1
        local maxLead  = 22

        local predictedPos = predictPosition(targetHRP, HRP.Position, projSpeed, minTime, maxTime, maxLead)
        if predictedPos then
            faceTarget(predictedPos)
        end
    end
elseif massaim then
    massaim = false
    if originalWS and originalJP and originalAutoRotate ~= nil then
        Humanoid.WalkSpeed = originalWS
        Humanoid.JumpPower = originalJP
        Humanoid.AutoRotate = originalAutoRotate
        originalWS, originalJP, originalAutoRotate = nil, nil, nil
    end
end


    -- NORMAL AIMBOT (tracking killers)
    if aiming and tick() - lastTriggerTime <= aimDuration then
        if not originalWS then
            originalWS = Humanoid.WalkSpeed
            originalJP = Humanoid.JumpPower
            originalAutoRotate = Humanoid.AutoRotate
        end

        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()

        if targetHRP then
            local vel = targetHRP.AssemblyLinearVelocity
            local predictedPos
            local reactionDelay = 0.2

            if vel.Magnitude > 0.4 then
                predictedPos = targetHRP.Position + vel * reactionDelay
            else
                predictedPos = targetHRP.Position
            end

            faceTarget(predictedPos)
        end
    elseif aiming then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
end)
