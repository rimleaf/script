-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local client = LocalPlayer

-- Config
local active = true
local aimDuration1 = 0.67 --WOW WHASHDO WOWOW 67 SIX SEVEEEEEEEEEEEEEEEEEEEN
local aimDuration2 = 0.2
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true,
    ["71685573690338"] = true,
    ["111313169447787"] = true,
    ["134958187822107"] = true,
    ["77124578197357"] = true,
    ["90499469533503"] = true
}

local twotimestab = {
    ["86545133269813"] = true
}

local entanglementanimation = {
    ["119181003138006"] = true
}
local massinfectionanimation = {
    ["131430497821198"] = true
}

-- State
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local enaim = false
local massaim = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil

--// Services
local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")

local LocalPlayer = Players.LocalPlayer

--// Config
local BrightnessValue = 2
local TimeOfDayValue = "12:00:00" -- Noon
local FogEndValue = 1e6
local GlobalShadowsValue = false
local MaxZoomValue = 100 -- change this to whatever max zoom you want

--// Function to enforce lighting
local function enforceSettings()
    Lighting.Brightness = BrightnessValue
    Lighting.TimeOfDay = TimeOfDayValue
    Lighting.FogEnd = FogEndValue
    Lighting.GlobalShadows = GlobalShadowsValue

    -- If Atmosphere exists, override its settings too
    local atmosphere = Lighting:FindFirstChildOfClass("Atmosphere")
    if atmosphere then
        atmosphere.Haze = 0
        atmosphere.Density = 0
    end
end

--// Function to enforce zoom
local function enforceZoom()
    if LocalPlayer and LocalPlayer.CameraMaxZoomDistance ~= MaxZoomValue then
        LocalPlayer.CameraMaxZoomDistance = MaxZoomValue
    end
end

-- Initial enforcement
enforceSettings()
enforceZoom()

-- Keep lighting consistent
Lighting:GetPropertyChangedSignal("Brightness"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("TimeOfDay"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("FogEnd"):Connect(enforceSettings)
Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(enforceSettings)
Lighting.ChildAdded:Connect(function(child)
    if child:IsA("Atmosphere") then
        enforceSettings()
    end
end)

-- Keep zoom consistent
LocalPlayer:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(enforceZoom)


local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not HRP then return nil end

    local nearest, nearestDist = nil, math.huge

    -- Check killers
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local humanoid = killer:FindFirstChildOfClass("Humanoid")
            local root = killer:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health > 0 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    -- Check players with 200+ HP
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")

            if humanoid and root and humanoid.Health >= 200 then
                local dist = (root.Position - HRP.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = root
                end
            end
        end
    end

    return nearest
end


local function getValidSurvivor()
    local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
    if not survivorFolder or not HRP then return nil end

    local nearest, nearestDist = nil, math.huge
    for _, survivor in ipairs(survivorFolder:GetChildren()) do
        local humanoid = survivor:FindFirstChildOfClass("Humanoid")
        local root = survivor:FindFirstChild("HumanoidRootPart")

        if humanoid and root and humanoid.Health > 0 then
            local dist = (root.Position - HRP.Position).Magnitude
            if dist < nearestDist then
                nearestDist = dist
                nearest = root
            end
        end
    end

    return nearest
end

local function getPlayingAnimationIds()
    local ids = {}
    if Humanoid then
        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            if track.Animation and track.Animation.AnimationId then
                local id = track.Animation.AnimationId:match("%d+")
                if id then
                    ids[id] = true
                end
            end
        end
    end
    return ids
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function isMoving(hrp)
    if not hrp then return false end
    return hrp.AssemblyLinearVelocity.Magnitude > 1
end

-- Predict position based on projectile speed and optionally add forgiveness
local function getPredictedPos(targetHRP, projSpeed, forgiveness, leadFactor)
    local dist = (targetHRP.Position - HRP.Position).Magnitude
    local travelTime = projSpeed > 0 and (dist / projSpeed) or 0
    local vel = targetHRP.AssemblyLinearVelocity

    local predictedPos
    if vel.Magnitude > 0.2 then
        leadFactor = leadFactor or 1.0
        predictedPos = targetHRP.Position + vel * travelTime * leadFactor
    else
        predictedPos = targetHRP.Position
    end

    if forgiveness and forgiveness > 0 then
        local dir = (predictedPos - HRP.Position)
        if dir.Magnitude > 0 then
            predictedPos = predictedPos + dir.Unit * forgiveness
        end
    end
    return predictedPos, dist
end

local function aimAt(pos)
    if not HRP then return end
    local dir = pos - HRP.Position
    if dir.Magnitude == 0 then return end
    local direction = dir.Unit
    local yRot = math.atan2(-direction.X, -direction.Z)
    HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
end

-- ENTANGLEMENT / MASS INFECTION AIM (search nearest alive player)
local function AimForDuration(duration, projSpeed, forgiveness, leadFactor)
    local start = tick()
    while tick() - start < duration do
        local survivorFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        local nearestHRP, nearestDist = nil, math.huge
        for _, survivor in ipairs(survivorFolder:GetChildren()) do
            local hum = survivor:FindFirstChildOfClass("Humanoid")
            local root = survivor:FindFirstChild("HumanoidRootPart")
            if hum and hum.Health > 0 and root and survivor ~= LocalPlayer.Character then
                local d = (root.Position - HRP.Position).Magnitude
                if d < nearestDist then
                    nearestDist = d
                    nearestHRP = root
                end
            end
        end

        if nearestHRP then
            local predictedPos = getPredictedPos(nearestHRP, projSpeed, forgiveness, leadFactor)
            aimAt(predictedPos)
        end

        RunService.Heartbeat:Wait()
    end
end

local entanglementTaskActive = false
local massInfectionTaskActive = false
local twotimestabTaskActive = false

RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    local playing = getPlayingAnimationIds()
    local triggered = false
    for id in pairs(trackedAnimations) do
        if playing[id] then
            triggered = true
            break
        end
    end

    -- check entanglement animation
    local entanglementTriggered = false
    for id in pairs(entanglementanimation) do
        if playing[id] then
            entanglementTriggered = true
            break
        end
    end

    -- check mass infection animation
    local massinfectionTriggered = false
    for id in pairs(massinfectionanimation) do
        if playing[id] then
            massinfectionTriggered = true
            break
        end
    end

    local twotimestabTriggered = false
    for id in pairs(twotimestab) do
        if playing[id] then
            twotimestabTriggered = true
            break
        end
    end

    -- normal tracked aimbot
    if triggered then
        lastTriggerTime = tick()
        aiming = true
    end

    if twotimestabTriggered then
        lastTriggerTime = tick()
        aiming = true
    end

    -- helper function: yaw-only face target
    local function faceTarget(targetPos)
        local rootPos = HRP.Position
        local lookAt = CFrame.lookAt(rootPos, targetPos, Vector3.yAxis)

        -- Extract only yaw from lookAt
        local _, y, _ = lookAt:ToOrientation()
        HRP.CFrame = CFrame.new(rootPos) * CFrame.Angles(0, y, 0)
    end

    -- ENTANGLEMENT AIMBOT (precise, no forgiveness, slight overshoot)
    if entanglementTriggered and not entanglementTaskActive then
        entanglementTaskActive = true
        task.spawn(function()
            AimForDuration(0.8, 100, 0, 1.30) -- 30% extra lead
            entanglementTaskActive = false
        end)
    end

    -- MASS INFECTION AIMBOT (slower proj, needs forgiveness, more overshoot)
    if massinfectionTriggered and not massInfectionTaskActive then
        massInfectionTaskActive = true
        task.spawn(function()
            AimForDuration(0.8, 40, 1.5, 1.30) -- 30% extra lead
            massInfectionTaskActive = false
        end)
    end

    -- TWOTIMESTAB AIMBOT (face where killer is aiming, predict 2 studs ahead)
    if aiming and tick() - lastTriggerTime <= aimDuration2 then
        if not originalWS then
            originalWS = Humanoid.WalkSpeed
            originalJP = Humanoid.JumpPower
            originalAutoRotate = Humanoid.AutoRotate
        end

        Humanoid.AutoRotate = false
        HRP.AssemblyAngularVelocity = Vector3.zero

        local targetHRP = getValidTarget()

        if targetHRP then
            local vel = targetHRP.AssemblyLinearVelocity
            local predictedPos
            local reactionDelay = 0.17

            if vel.Magnitude > 0.4 then
                predictedPos = targetHRP.Position + vel * reactionDelay
            else
                predictedPos = targetHRP.Position
            end

            faceTarget(predictedPos)
        end
    elseif aiming then
        aiming = false
        if originalWS and originalJP and originalAutoRotate ~= nil then
            Humanoid.WalkSpeed = originalWS
            Humanoid.JumpPower = originalJP
            Humanoid.AutoRotate = originalAutoRotate
            originalWS, originalJP, originalAutoRotate = nil, nil, nil
        end
    end
end)
wait(0.1)
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Stats = game:GetService("Stats")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local StarterGui = game:GetService("StarterGui")

-- You can trigger notifications later in your script:

-- GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ChanceAimbotUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

-- Main draggable frame
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 180, 0, 110)
mainFrame.Position = UDim2.new(0, 20, 0, 100)
mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
mainFrame.Active = true
mainFrame.Parent = screenGui

-- Make mainFrame auto-resize
mainFrame.AutomaticSize = Enum.AutomaticSize.Y
mainFrame.Size = UDim2.new(0, 180, 0, 0) -- only width fixed, height auto

-- Add a layout to handle stacking
local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 5)
layout.FillDirection = Enum.FillDirection.Vertical
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Parent = mainFrame

-- Dragging logic
local dragging, dragInput, dragStart, startPos
mainFrame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = mainFrame.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

mainFrame.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        local delta = input.Position - dragStart
        mainFrame.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
end)



-- Hide/Unhide Square Button
local hideButton = Instance.new("TextButton")
hideButton.Size = UDim2.new(0, 40, 0, 40) -- square shape
hideButton.Position = UDim2.new(0, 20, 0, 20) -- top-left corner (adjust if you want)
hideButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
hideButton.TextColor3 = Color3.new(1, 1, 1)
hideButton.TextScaled = true
hideButton.Text = "HIDE" -- simple menu icon
hideButton.Active = true
hideButton.Draggable = true -- makes it draggable
hideButton.Parent = screenGui

-- Track hidden state
local uiHidden = false

hideButton.MouseButton1Click:Connect(function()
    uiHidden = not uiHidden

    -- Loop through all children of screenGui except the hideButton itself
    for _, child in ipairs(screenGui:GetChildren()) do
        if child ~= hideButton then
            child.Visible = not uiHidden
        end
    end

    hideButton.Text = uiHidden and "UNHIDE" or "HIDE" -- indicator changes
end)

-- Toggle Button
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 140, 0, 30)
toggleButton.LayoutOrder = 1
toggleButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Text = "Chance Aim: OFF"
toggleButton.Parent = mainFrame

-- Mode Button
local modeButton = Instance.new("TextButton")
modeButton.Size = UDim2.new(0, 140, 0, 30)
modeButton.LayoutOrder = 2
modeButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
modeButton.TextColor3 = Color3.new(1, 1, 1)
modeButton.Text = "Prediction Mode: Velocity"
modeButton.Parent = mainFrame

local shooting = false

-- Aim Mode Button
local aimModeButton = Instance.new("TextButton")
aimModeButton.Size = UDim2.new(0, 140, 0, 30)
aimModeButton.LayoutOrder = 4
aimModeButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
aimModeButton.TextColor3 = Color3.new(1, 1, 1)
aimModeButton.Text = "Aim Behavior Mode: Normal"
aimModeButton.Parent = mainFrame

-- Spin Speed Box (seconds per 360)
local spinSpeedBox = Instance.new("TextBox")
spinSpeedBox.Size = UDim2.new(0, 140, 0, 30)
spinSpeedBox.LayoutOrder = 5
spinSpeedBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
spinSpeedBox.TextColor3 = Color3.new(1, 1, 1)
spinSpeedBox.Text = "0.5" -- default duration
spinSpeedBox.PlaceholderText = "Spin Duration/Speed (sec)"
spinSpeedBox.ClearTextOnFocus = false
spinSpeedBox.Visible = false
spinSpeedBox.Parent = mainFrame



-- Prediction Box (only for velocity mode)
local predictionBox = Instance.new("TextBox")
predictionBox.Size = UDim2.new(0, 140, 0, 30)
predictionBox.LayoutOrder = 3
predictionBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
predictionBox.TextColor3 = Color3.new(1, 1, 1)
predictionBox.Text = "4"
predictionBox.PlaceholderText = "Prediction (Velocity only)"
predictionBox.ClearTextOnFocus = false
predictionBox.Visible = true
predictionBox.Parent = mainFrame

-- Message When Aim UI
local messageToggleButton = Instance.new("TextButton")
messageToggleButton.Size = UDim2.new(0, 140, 0, 30)
messageToggleButton.LayoutOrder = 6
messageToggleButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
messageToggleButton.TextColor3 = Color3.new(1, 1, 1)
messageToggleButton.Text = "Message When Aim: OFF"
messageToggleButton.Parent = mainFrame

local messageBox = Instance.new("TextBox")
messageBox.Size = UDim2.new(0, 140, 0, 30)
messageBox.LayoutOrder = 7
messageBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
messageBox.TextColor3 = Color3.new(1, 1, 1)
messageBox.PlaceholderText = "Message to send when aiming"
messageBox.ClearTextOnFocus = false
messageBox.Text = "" -- default text, change if you want
messageBox.Visible = false
messageBox.Parent = mainFrame

-- Custom Shoot Anim Toggle
local customAnimToggle = Instance.new("TextButton")
customAnimToggle.Size = UDim2.new(0, 140, 0, 30)
customAnimToggle.LayoutOrder = 8
customAnimToggle.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
customAnimToggle.TextColor3 = Color3.new(1, 1, 1)
customAnimToggle.Text = "Custom Shoot Anim: OFF"
customAnimToggle.Parent = mainFrame

local customAnimBox = Instance.new("TextBox")
customAnimBox.Size = UDim2.new(0, 140, 0, 30)
customAnimBox.LayoutOrder = 9
customAnimBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
customAnimBox.TextColor3 = Color3.new(1, 1, 1)
customAnimBox.PlaceholderText = "Enter Anim ID"
customAnimBox.Text = ""
customAnimBox.ClearTextOnFocus = false
customAnimBox.Visible = false
customAnimBox.Parent = mainFrame

-- AUTO COINFLIP UI -------------------------------------------------
local autoCoinflipToggle = Instance.new("TextButton")
autoCoinflipToggle.Size = UDim2.new(0, 140, 0, 30)
autoCoinflipToggle.LayoutOrder = 10
autoCoinflipToggle.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
autoCoinflipToggle.TextColor3 = Color3.new(1, 1, 1)
autoCoinflipToggle.Text = "Auto Coinflip: OFF"
autoCoinflipToggle.Parent = mainFrame

local chargesModeButton = Instance.new("TextButton")
chargesModeButton.Size = UDim2.new(0, 140, 0, 30)
chargesModeButton.LayoutOrder = 11
chargesModeButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
chargesModeButton.TextColor3 = Color3.new(1, 1, 1)
chargesModeButton.Visible = false
chargesModeButton.Text = "Charges: 3" -- default
chargesModeButton.Parent = mainFrame

-- Auto-coinflip state
local autoCoinflip = false
local coinflipTargetCharge = "3" -- string "1","2","3"
local coinflipRoutine = nil

-- helper to read the charges text safely
local function readCoinflipChargesText()
    local ok, txt = pcall(function()
        local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
        if not mainUI then return nil end
        local abil = mainUI:FindFirstChild("AbilityContainer")
        if not abil then return nil end
        local coin = abil:FindFirstChild("Reroll")
        if not coin then return nil end
        local chargesLabel = coin:FindFirstChild("Charges")
        if not chargesLabel then return nil end
        return tostring(chargesLabel.Text)
    end)
    if ok then return txt end
    return nil
end

-- cycle charges mode between "1", "2", "3"
chargesModeButton.MouseButton1Click:Connect(function()
    if coinflipTargetCharge == "1" then
        coinflipTargetCharge = "2"
    elseif coinflipTargetCharge == "2" then
        coinflipTargetCharge = "3"
    else
        coinflipTargetCharge = "1"
    end
    chargesModeButton.Text = "Charges: " .. coinflipTargetCharge
end)

-- remote ref (safe wait)
local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

-- toggling the auto coinflip
-- auto coinflip toggle
autoCoinflipToggle.MouseButton1Click:Connect(function()
    autoCoinflip = not autoCoinflip
    autoCoinflipToggle.Text = autoCoinflip and "Auto Coinflip: ON" or "Auto Coinflip: OFF"

    -- show/hide charges button
    chargesModeButton.Visible = autoCoinflip
end)

-- keep checking each frame
local lastCoinflipTime = 0
local coinflipCooldown = 0.15 -- seconds between coinflips (adjust as you like)

RunService.RenderStepped:Connect(function()
    if autoCoinflip then
        local charges = tonumber(readCoinflipChargesText())
        local target = tonumber(coinflipTargetCharge)

        if charges and target and charges < target then
            local now = tick()
            if now - lastCoinflipTime >= coinflipCooldown then
                lastCoinflipTime = now
                pcall(function()
                    RemoteEvent:FireServer(table.unpack({
                        [1] = "UseActorAbility",
                        [2] = "CoinFlip",
                    }))
                end)
            end
        end
    end
end)

-- State
local useCustomAnim = false
local loadedCustomAnimTrack = nil

customAnimToggle.MouseButton1Click:Connect(function()
    useCustomAnim = not useCustomAnim
    customAnimToggle.Text = useCustomAnim and "Custom Shoot Anim: ON" or "Custom Shoot Anim: OFF"
    customAnimBox.Visible = useCustomAnim
end)

-- Config
local active = false
local usePingMode = false
local aimDuration = 1.7
local aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli"}
-- trackedAnimations not used anymore, kept harmlessly in case you want to revert
local trackedAnimations = {
    ["103601716322988"] = true,
    ["133491532453922"] = true,
    ["86371356500204"] = true,
    ["76649505662612"] = true,
    ["81698196845041"] = true
}

local spinDuration = tonumber(spinSpeedBox.Text) or 0.5

-- State
local messageWhenAim = false
local messageSentThisAim = false
local Humanoid, HRP = nil, nil
local lastTriggerTime = 0
local aiming = false
local originalWS, originalJP, originalAutoRotate = nil, nil, nil
local aimMode = "Normal" -- or "360"

messageToggleButton.MouseButton1Click:Connect(function()
    messageWhenAim = not messageWhenAim
    messageToggleButton.Text = messageWhenAim and "Message When Aim: ON" or "Message When Aim: OFF"
    messageBox.Visible = messageWhenAim
end)

-- NEW: track previous visibility so we only trigger on the rising edge
local prevFlintVisibleAim = false
local prevFlintVisibleShoot = false
-- use prevFlintVisibleAim in the aiming loop
-- use prevFlintVisibleShoot in the shooting loop
-- prediction only if target is moving faster than this (studs/sec)
local movementThreshold = 0.5
-- Message-when-aim state + chat helper

local ChatEvents = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
local SayMessageRequest = ChatEvents and ChatEvents:FindFirstChild("SayMessageRequest")

local function sendChatMessage(text)
    if not text or text:match("^%s*$") then return end
    local TextChatService = game:GetService("TextChatService")
    local channel = TextChatService.TextChannels.RBXGeneral

    channel:SendAsync(text)
end

local function playCustomShootAnim()
    if not useCustomAnim or not Humanoid then return end

    local animId = tonumber(customAnimBox.Text)
    if not animId then return end

    -- stop all current tracks
    for _, track in ipairs(Humanoid.Animator:GetPlayingAnimationTracks()) do
        track:Stop()
    end

    -- load and play
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://" .. animId
    local track = Humanoid:FindFirstChild("Animator"):LoadAnimation(anim)
    loadedCustomAnimTrack = track
    track:Play()

    -- if it's looped, stop it after 1.7s
    if track.Looped then
        delay(1.7, function()
            if track.IsPlaying then
                track:Stop()
            end
        end)
    end
end

-- UI Button Logic
toggleButton.MouseButton1Click:Connect(function()
    active = not active
    toggleButton.Text = active and "Chance Aim: ON" or "Chance Aim: OFF"
end)

local predictionMode = "Velocity" -- default

modeButton.MouseButton1Click:Connect(function()
    if predictionMode == "Velocity" then
        predictionMode = "Ping"
        modeButton.Text = "Prediction Mode: Velocity (Ping Adjust)"
        predictionBox.Visible = false
    elseif predictionMode == "Ping" then
        predictionMode = "Infront HRP"
        modeButton.Text = "Prediction Mode: Infront HRP"
        predictionBox.Visible = true
        predictionBox.PlaceholderText = "Studs Infront Killer HRP"
    elseif predictionMode == "Infront HRP" then
        predictionMode = "Infront HRP (Ping Adjust)"
        modeButton.Text = "Prediction Mode: Infront HRP (Ping Adjust)"
        predictionBox.Visible = false
    else
        predictionMode = "Velocity"
        modeButton.Text = "Prediction Mode: Velocity"
        predictionBox.Visible = true
        predictionBox.PlaceholderText = "Prediction (Velocity only)"
    end
end)

aimModeButton.MouseButton1Click:Connect(function()
    if aimMode == "Normal" then
        aimMode = "360"
        aimModeButton.Text = "Aim Behavior Mode: 360"
        spinSpeedBox.Visible = true -- show only in 360 mode
    else
        aimMode = "Normal"
        aimModeButton.Text = "Aim Behavior Mode: Normal"
        spinSpeedBox.Visible = false -- hide in normal mode
    end
end)

-- Helpers
local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart, target:FindFirstChild("Humanoid")
            end
        end
    end
    return nil, nil
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end

if LocalPlayer.Character then
    setupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

-- Ping mode function
local function getPingSeconds()
    local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then
        return pingStat:GetValue() / 1000
    end
    return 0.1
end

spinSpeedBox.FocusLost:Connect(function()
    spinDuration = tonumber(spinSpeedBox.Text) or 0.5
end)

local function getPredictedAimPosPing(targetHRP, killerHumanoid)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity

    -- if target is basically standing still, don't predict — just aim at current position
    if velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    end

    -- otherwise predict using velocity * ping
    return targetHRP.Position + (velocity * ping)
end

-- Predict N studs in front of killer HRP using HRP.LookVector scaled by ping
local function getPredictedAimPosInfrontHRPPing(targetHRP)
    local ping = getPingSeconds()
    local studs = ping * 60 -- tweak multiplier until aim feels right

    -- if killer is standing still, just return HRP position
    if targetHRP.Velocity.Magnitude <= movementThreshold then
        return targetHRP.Position
    end

    return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
end

-- NEW: Flintlock visibility check
local function isFlintlockVisible()
    if not LocalPlayer.Character then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end

    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end

    if flint.Transparency >= 1 then
        return false
    end
    return true
end

-- Main loop
RunService.RenderStepped:Connect(function()
    if not active or not Humanoid or not HRP then return end

    -- EDGE DETECTION: only set the trigger when Flintlock becomes visible (false -> true)
    local isVisible = isFlintlockVisible()
    if isVisible and not prevFlintVisibleAim and not aiming then
        lastTriggerTime = tick()
        aiming = true
    end
    prevFlintVisibleAim = isVisible

    if aiming then
        local elapsed = tick() - lastTriggerTime

        if aimMode == "360" then
            -- Phase 1: spin for 1.2s
            if elapsed <= spinDuration then
                -- full 360 spin over the spindurstion
                local spinProgress = elapsed / spinDuration
                local spinAngle = math.rad(360 * spinProgress)
                HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0)

            -- Phase 2: short aim (0.7s)
            elseif elapsed <= spinDuration + 0.7 then
                -- same as your normal aiming logic, but time-limited
                if not originalWS then
                    originalWS = Humanoid.WalkSpeed
                    originalJP = Humanoid.JumpPower
                    originalAutoRotate = Humanoid.AutoRotate
                end

                Humanoid.AutoRotate = false
                HRP.AssemblyAngularVelocity = Vector3.zero

                local targetHRP, killerHumanoid = getValidTarget()
                if targetHRP then
                    local aimPos
                    if predictionMode == "Ping" then
                        aimPos = getPredictedAimPosPing(targetHRP, killerHumanoid)
                    elseif predictionMode == "Infront HRP" then
                        local studs = tonumber(predictionBox.Text) or 0
                        if targetHRP.Velocity.Magnitude > movementThreshold then
                            aimPos = targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
                        else
                            aimPos = targetHRP.Position
                        end
                    elseif predictionMode == "Infront HRP (Ping Adjust)" then
                        aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                    else
                        -- Velocity mode
                        local prediction = tonumber(predictionBox.Text) or 0
                        if targetHRP.Velocity.Magnitude <= movementThreshold then
                            aimPos = targetHRP.Position
                        else
                            aimPos = targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
                        end
                    end

                    if aimPos then
                        local direction = (aimPos - HRP.Position).Unit
                        local yRot = math.atan2(-direction.X, -direction.Z)
                        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                    end
                end

            else
                -- Done with spin + aim
                aiming = false
                if originalWS and originalJP and originalAutoRotate ~= nil then
                    Humanoid.WalkSpeed = originalWS
                    Humanoid.JumpPower = originalJP
                    Humanoid.AutoRotate = originalAutoRotate
                    originalWS, originalJP, originalAutoRotate = nil, nil, nil
                end
            end

        else -- Normal mode (what you already had)
            if elapsed <= aimDuration then
                if not originalWS then
                    originalWS = Humanoid.WalkSpeed
                    originalJP = Humanoid.JumpPower
                    originalAutoRotate = Humanoid.AutoRotate
                end

                Humanoid.AutoRotate = false
                HRP.AssemblyAngularVelocity = Vector3.zero

                local targetHRP, killerHumanoid = getValidTarget()
                if targetHRP then
                    local aimPos
                    if predictionMode == "Ping" then
                        aimPos = getPredictedAimPosPing(targetHRP, killerHumanoid)
                    elseif predictionMode == "Infront HRP" then
                        local studs = tonumber(predictionBox.Text) or 0
                        if targetHRP.Velocity.Magnitude > movementThreshold then
                            aimPos = targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
                        else
                            aimPos = targetHRP.Position
                        end
                    elseif predictionMode == "Infront HRP (Ping Adjust)" then
                        aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                    else
                        -- Velocity mode
                        local prediction = tonumber(predictionBox.Text) or 0
                        if targetHRP.Velocity.Magnitude <= movementThreshold then
                            aimPos = targetHRP.Position
                        else
                            aimPos = targetHRP.Position + (targetHRP.Velocity * (prediction / 60))
                        end
                    end

                    if aimPos then
                        local direction = (aimPos - HRP.Position).Unit
                        local yRot = math.atan2(-direction.X, -direction.Z)
                        HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                    end
                end
            else
                aiming = false
                if originalWS and originalJP and originalAutoRotate ~= nil then
                    Humanoid.WalkSpeed = originalWS
                    Humanoid.JumpPower = originalJP
                    Humanoid.AutoRotate = originalAutoRotate
                    originalWS, originalJP, originalAutoRotate = nil, nil, nil
                end
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    local isVisible = isFlintlockVisible()
    if isVisible and not prevFlintVisibleShoot and not shooting then
        lastTriggerTime = tick()
        shooting = true
        messageSentThisAim = false
        if messageWhenAim then
            -- send immediately when the aim starts (on
            sendChatMessage(messageBox.Text)
            messageSentThisAim = true
        end
    end
    prevFlintVisibleShoot = isVisible
    if shooting then
        if useCustomAnim then
            playCustomShootAnim()
        end
        messageSentThisAim = false
        shooting = false
    end
end)
