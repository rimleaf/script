-- Lead Hub (Full) â€” Sound Auto Block + Charge + Clone + Generators + ESP + AutoPunch
-- Drop-in replacement for your previous Lead Hub LocalScript

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local StarterGui = game:GetService("StarterGui")
local Debris = game:GetService("Debris")
local Stats = game:GetService("Stats")

local lp = Players.LocalPlayer

-- Rayfield
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Window = Rayfield:CreateWindow({
    Name = "Lead Hub",
    LoadingTitle = "Lead Hub",
    LoadingSubtitle = "by Triplex",
    ConfigurationSaving = {Enabled = true, FolderName = "LeadHub", FileName = "Settings"},
    Discord = {Enabled = false},
    KeySystem = false
})

-- Tabs
local CombatTab = Window:CreateTab("Combat", 4483362458)
local GeneratorTab = Window:CreateTab("Generators", 4483362458)
local ESPTab = Window:CreateTab("ESP", 4483362458)
local MiscTab = Window:CreateTab("Misc", 4483362458)

-- ================== CORE STATE & CACHE ==================
local KillersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

-- Modes (mutually exclusive)
local autoblocktype = "Block" -- "Block" | "Charge" | "7n7 Clone"
local autoBlockAudioOn = true
local autoBlockMode_Block = true
local autoBlockMode_Charge = false
local autoBlockMode_Clone = false

-- UI caches
local cachedPlayerGui = nil
local cachedPunchBtn, cachedBlockBtn, cachedChargeBtn, cachedCloneBtn = nil, nil, nil, nil
local cachedCharges, cachedCooldown = nil, nil

local function refreshUIRefs()
    cachedPlayerGui = lp:FindFirstChild("PlayerGui")
    local main = cachedPlayerGui and cachedPlayerGui:FindFirstChild("MainUI")
    if main then
        local ability = main:FindFirstChild("AbilityContainer")
        cachedPunchBtn = ability and ability:FindFirstChild("Punch")
        cachedBlockBtn = ability and ability:FindFirstChild("Block")
        cachedChargeBtn = ability and ability:FindFirstChild("Charge")
        cachedCloneBtn = ability and ability:FindFirstChild("Clone")
        cachedCharges = cachedPunchBtn and cachedPunchBtn:FindFirstChild("Charges")
        cachedCooldown = cachedBlockBtn and cachedBlockBtn:FindFirstChild("CooldownTime")
    else
        cachedPunchBtn, cachedBlockBtn, cachedCharges, cachedCooldown, cachedChargeBtn, cachedCloneBtn = nil, nil, nil, nil, nil, nil
    end
end

refreshUIRefs()
lp.CharacterAdded:Connect(function() task.delay(0.5, refreshUIRefs) end)
if cachedPlayerGui then
    cachedPlayerGui.ChildAdded:Connect(function(child) if child.Name == "MainUI" then task.delay(0.02, refreshUIRefs) end end)
end

local function SendNotif(title, text, duration)
    pcall(function() StarterGui:SetCore("SendNotification", {Title = title or "Notice", Text = text or "", Duration = duration or 4}) end)
end

-- ================== TUNABLES & DEPENDENCIES ==================
local detectionRange = 10
local detectionRangeSq = detectionRange * detectionRange
local reactionSpeed = 1.0 -- maps to AUDIO_SOUND_THROTTLE by slider

-- predictive / smoothing constants
local SMOOTHING_LERP = 0.22
local PRED_SECONDS_FORWARD = 0.25
local PRED_SECONDS_LATERAL = 0.18
local PRED_MAX_FORWARD = 6
local PRED_MAX_LATERAL = 4
local ANG_TURN_MULTIPLIER = 0.6
local predictionStrength = 1
local predictionTurnStrength = 1
local blockPartsSizeMultiplier = 1

-- anti-flick (BD parts) defaults
local antiFlickOn = false
local antiFlickParts = 4
local antiFlickBaseOffset = 2.7
local antiFlickOffsetStep = 0
local antiFlickDelay = 0
local stagger = 0

-- audio timing
local AUDIO_PREDICT_DT = 0.08
local AUDIO_LOCAL_COOLDOWN = 0.35
local AUDIO_SOUND_THROTTLE = reactionSpeed
local lastLocalBlockTime = 0

-- ID list (sound IDs)
local autoBlockTriggerSounds = {
    ["102228729296384"] = true, ["140242176732868"] = true, ["112809109188560"] = true,
    ["136323728355613"] = true, ["115026634746636"] = true, ["84116622032112"] = true,
    ["108907358619313"] = true, ["127793641088496"] = true, ["86174610237192"] = true,
    ["95079963655241"] = true, ["101199185291628"] = true, ["119942598489800"] = true,
    ["84307400688050"] = true, ["113037804008732"] = true, ["105200830849301"] = true,
    ["75330693422988"] = true, ["82221759983649"] = true, ["81702359653578"] = true,
    ["108610718831698"] = true, ["112395455254818"] = true, ["109431876587852"] = true,
    ["109348678063422"] = true, ["85853080745515"] = true, ["12222216"] = true,
    ["105840448036441"] = true, ["114742322778642"] = true,
}

-- remote fallback for block
local function fireRemoteBlock()
    pcall(function()
        local net = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
        net:FireServer("UseActorAbility", "Block")
    end)
end

-- ================== UI: Combat Controls ==================
CombatTab:CreateToggle({Name="Auto Audio Block (Global)", CurrentValue=true, Flag="AutoAudioGlobal", Callback=function(val) autoBlockAudioOn = val end})

CombatTab:CreateToggle({
    Name="Auto Block (Block)",
    CurrentValue=true,
    Callback=function(val)
        autoBlockMode_Block = val
        if val then
            autoBlockMode_Charge = false
            autoBlockMode_Clone = false
            autoblocktype = "Block"
            SendNotif("Lead Hub", "Mode: Block", 2)
        else
            if not autoBlockMode_Charge and not autoBlockMode_Clone then
                autoBlockMode_Block = true
                autoblocktype = "Block"
            end
        end
    end
})

CombatTab:CreateToggle({
    Name="Auto Charge",
    CurrentValue=false,
    Callback=function(val)
        autoBlockMode_Charge = val
        if val then
            autoBlockMode_Block = false
            autoBlockMode_Clone = false
            autoblocktype = "Charge"
            SendNotif("Lead Hub", "Mode: Charge", 2)
        else
            if not autoBlockMode_Block and not autoBlockMode_Clone then
                autoBlockMode_Block = true
                autoblocktype = "Block"
            end
        end
    end
})

CombatTab:CreateToggle({
    Name="Auto Clone (7n7)",
    CurrentValue=false,
    Callback=function(val)
        autoBlockMode_Clone = val
        if val then
            autoBlockMode_Block = false
            autoBlockMode_Charge = false
            autoblocktype = "7n7 Clone"
            SendNotif("Lead Hub", "Mode: 7n7 Clone", 2)
        else
            if not autoBlockMode_Block and not autoBlockMode_Charge then
                autoBlockMode_Block = true
                autoblocktype = "Block"
            end
        end
    end
})

CombatTab:CreateSlider({
    Name = "Detection Range (studs)",
    Range = {5, 40},
    Increment = 1,
    Suffix = "studs",
    CurrentValue = detectionRange,
    Callback = function(val)
        detectionRange = val
        detectionRangeSq = detectionRange * detectionRange
    end
})

CombatTab:CreateSlider({
    Name = "Reaction Speed (throttle seconds)",
    Range = {0.1, 2.5},
    Increment = 0.05,
    Suffix = "s",
    CurrentValue = AUDIO_SOUND_THROTTLE,
    Callback = function(val)
        AUDIO_SOUND_THROTTLE = val
    end
})

CombatTab:CreateToggle({Name="Fling Punch", CurrentValue=false, Callback=function(val) end})
CombatTab:CreateToggle({Name="Infinite Stamina", CurrentValue=true, Callback=function(val) end})

-- ================== Infinite Stamina (keeps original behavior) ==================
local infiniteStamina = true
local function enableInfiniteStamina()
    local success, StaminaModule = pcall(function() return require(ReplicatedStorage.Systems.Character.Game.Sprinting) end)
    if not success or not StaminaModule then return end
    StaminaModule.StaminaLossDisabled = true
    task.spawn(function()
        while infiniteStamina do
            task.wait(0.1)
            StaminaModule.Stamina = StaminaModule.MaxStamina
            if StaminaModule.StaminaChanged then pcall(function() StaminaModule.StaminaChanged:Fire() end) end
        end
    end)
end
enableInfiniteStamina()

-- ================== Utility: Detection circles (range visual) ==================
local detectionCircles = {}
local killerCirclesVisible = true

local groundCastParams = RaycastParams.new()
groundCastParams.FilterType = Enum.RaycastFilterType.Exclude
groundCastParams.IgnoreWater = true

local function setCircleAtGround(killer, circle)
    local hrp = killer:FindFirstChild("HumanoidRootPart")
    if not hrp or not circle then return end
    groundCastParams.FilterDescendantsInstances = {killer}
    local origin = hrp.Position
    local result = workspace:Raycast(origin, Vector3.new(0,-1000,0), groundCastParams)
    local groundY = result and result.Position.Y or (origin.Y - 3)
    local offsetY = (groundY - origin.Y) + 0.03
    circle.CFrame = CFrame.new(0, offsetY, 0) * CFrame.Angles(math.rad(90), 0, 0)
end

local function addKillerCircle(killer)
    if not killer:FindFirstChild("HumanoidRootPart") then return end
    if detectionCircles[killer] then return end
    local hrp = killer.HumanoidRootPart
    local circle = Instance.new("CylinderHandleAdornment")
    circle.Name = "KillerDetectionCircle"
    circle.Adornee = hrp
    circle.Color3 = Color3.fromRGB(255,0,0)
    circle.AlwaysOnTop = true
    circle.ZIndex = 0
    circle.Transparency = 0.7
    circle.Radius = detectionRange / 1.5
    circle.Height = 0.1
    circle.Parent = hrp
    detectionCircles[killer] = circle
    setCircleAtGround(killer, circle)
end

local function removeKillerCircle(killer)
    if detectionCircles[killer] then detectionCircles[killer]:Destroy() detectionCircles[killer] = nil end
end

local function refreshKillerCircles()
    for _, killer in ipairs(KillersFolder:GetChildren()) do
        if killerCirclesVisible then addKillerCircle(killer) else removeKillerCircle(killer) end
    end
end

RunService.RenderStepped:Connect(function()
    for killer, circle in pairs(detectionCircles) do
        if circle and circle.Parent then
            circle.Radius = detectionRange / 1.5
            setCircleAtGround(killer, circle)
        end
    end
end)

KillersFolder.ChildAdded:Connect(function(killer)
    if killerCirclesVisible then
        task.spawn(function()
            local hrp = killer:WaitForChild("HumanoidRootPart", 5)
            if hrp then addKillerCircle(killer) end
        end)
    end
end)
KillersFolder.ChildRemoved:Connect(function(killer) removeKillerCircle(killer) end)

-- Range visual toggle in UI (keuses original label)
CombatTab:CreateToggle({Name="Range Visual", CurrentValue=true, Callback=function(state) killerCirclesVisible = state refreshKillerCircles() end})

-- ================== AutoPunch / Aimbot (kept from original) ==================
local netRem = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local function firePunch()
    pcall(function() netRem:FireServer("UseActorAbility","Punch") end)
end

local killersFolder = Workspace:WaitForChild("Players"):WaitForChild("Killers")
local apRange = 7
local autoPunchOn = true

local function closestKiller()
    local char = lp.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local nearest, nearestDist = nil, math.huge
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local kr = killer:FindFirstChild("HumanoidRootPart")
        if kr then
            local dist = (kr.Position - root.Position).Magnitude
            if dist <= apRange and dist < nearestDist then
                nearest = kr
                nearestDist = dist
            end
        end
    end
    return nearest
end

local function getPredictedPosition(hrp, hum)
    if not hrp or not hum then return hrp.Position end
    local moveDir = hum.MoveDirection
    local velocity = hrp.Velocity
    local predictionTime = 0.45
    if moveDir.Magnitude < 1 and velocity.Magnitude < 1 then return hrp.Position end
    local offset
    if moveDir.Magnitude > 0.1 then offset = moveDir.Unit * hum.WalkSpeed * predictionTime else offset = velocity * predictionTime end
    if offset.Magnitude > 6 then offset = offset.Unit * 6 end
    return hrp.Position + offset
end

local aiming = false
RunService.RenderStepped:Connect(function()
    if not autoPunchOn or aiming then return end
    local gui = lp:FindFirstChild("PlayerGui")
    local chargesObj = gui and gui:FindFirstChild("MainUI")
        and gui.MainUI:FindFirstChild("AbilityContainer")
        and gui.MainUI.AbilityContainer:FindFirstChild("Punch")
        and gui.MainUI.AbilityContainer.Punch:FindFirstChild("Charges")
    if chargesObj and chargesObj.Text == "1" then
        local targetRoot = closestKiller()
        local root = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot and root then
            aiming = true
            firePunch()
            local startTime = tick()
            task.spawn(function()
                while tick() - startTime < 0.5 and root and targetRoot and targetRoot.Parent do
                    local humanoid = targetRoot.Parent:FindFirstChildOfClass("Humanoid")
                    local predictedPosition = getPredictedPosition(targetRoot, humanoid)
                    pcall(function() root.CFrame = CFrame.lookAt(root.Position, predictedPosition) end)
                    task.wait()
                end
                aiming = false
            end)
        end
    end
end)

-- ================== Generators (kept from original) ==================
local generatorCooldown = 2.5
local function GeneratorOnce()
    local IngameMapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame")
    local SubMapFolder = IngameMapFolder and IngameMapFolder:FindFirstChild("Map")
    if SubMapFolder then
        for _, g in ipairs(SubMapFolder:GetChildren()) do
            if g.Name == "Generator" and g.Progress.Value < 100 then
                wait(0.5)
                g.Remotes.RE:FireServer()
            end
        end
    end
end

GeneratorTab:CreateToggle({
    Name = "Auto Generator",
    CurrentValue = false,
    Callback = function(enabled)
        if GeneratorTab._loop then GeneratorTab._loop:Disconnect() GeneratorTab._loop = nil end
        if enabled then
            GeneratorTab._timer = 0
            GeneratorTab._loop = RunService.Heartbeat:Connect(function(dt)
                GeneratorTab._timer = GeneratorTab._timer + dt
                if GeneratorTab._timer >= generatorCooldown then
                    GeneratorTab._timer = 0
                    GeneratorOnce()
                end
            end)
        end
    end
})

GeneratorTab:CreateSlider({
    Name = "Auto Generator Delay",
    Range = {2.5, 5},
    Increment = 0.1,
    Suffix = "s",
    CurrentValue = generatorCooldown,
    Callback = function(val)
        generatorCooldown = val
    end
})

-- ================== ESP (kept from original) ==================
local espKillers = false
local espSurvivors = false
local espItems = false
local espGenerators = false

local function getOrCreateHighlight(obj, color, fillTrans, outlineTrans)
    wait(0.1)
    for i = 1, 3 do
        local h = obj:FindFirstChild("ESP_Highlight")
        if not h then
            h = Instance.new("Highlight")
            h.Name = "ESP_Highlight"
            h.Adornee = obj
            h.Parent = obj
        end
        h.FillColor = color
        h.OutlineColor = Color3.new(0,0,0)
        h.FillTransparency = fillTrans
        h.OutlineTransparency = outlineTrans - (i * 0.2)
        return h
    end
end

local function clearESP(obj)
    local h = obj:FindFirstChild("ESP_Highlight")
    if h then h:Destroy() end
    local b = obj:FindFirstChild("ESP_Billboard")
    if b then b:Destroy() end
end

local function applyItemESP(obj)
    getOrCreateHighlight(obj, Color3.fromRGB(0,0,139), 0.6, 0.6)
    if not obj:FindFirstChild("ESP_Billboard") then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESP_Billboard"
        billboard.Size = UDim2.new(0,100,0,30)
        billboard.StudsOffset = Vector3.new(0,3,0)
        billboard.AlwaysOnTop = true
        billboard.Adornee = obj
        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1,0,1,0)
        textLabel.BackgroundTransparency = 1
        textLabel.TextColor3 = Color3.fromRGB(0,0,139)
        textLabel.Font = Enum.Font.SourceSansBold
        textLabel.TextSize = 14
        textLabel.Text = obj.Name
        textLabel.Parent = billboard
        billboard.Parent = obj
    end
end

task.spawn(function()
    while true do
        local mapFolder = Workspace:FindFirstChild("Map") and Workspace.Map:FindFirstChild("Ingame") and Workspace.Map.Ingame:FindFirstChild("Map")
        -- Killers
        if espKillers then
            local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
            if killers then for _, k in ipairs(killers:GetChildren()) do getOrCreateHighlight(k, Color3.fromRGB(255,0,0), 0.5, 0.3) end end
        else
            local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers")
            if killers then for _, k in ipairs(killers:GetChildren()) do clearESP(k) end end
        end
        -- Survivors
        if espSurvivors then
            local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
            if survivors then for _, s in ipairs(survivors:GetChildren()) do getOrCreateHighlight(s, Color3.fromRGB(255,255,255), 0.5, 0.3) end end
        else
            local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors")
            if survivors then for _, s in ipairs(survivors:GetChildren()) do clearESP(s) end end
        end
        -- Items & Generators
        if mapFolder then
            for _, obj in ipairs(mapFolder:GetChildren()) do
                if espItems and (obj.Name == "Medkit" or obj.Name == "BloxyCola") then
                    applyItemESP(obj)
                elseif not espItems and (obj.Name == "Medkit" or obj.Name == "BloxyCola") then
                    clearESP(obj)
                end
                if espGenerators and obj.Name == "Generator" then
                    local progressVal = obj:FindFirstChild("Progress")
                    if progressVal and progressVal.Value < 100 then
                        getOrCreateHighlight(obj, Color3.fromRGB(255,255,0), 0.5, 0.3)
                    else
                        clearESP(obj)
                    end
                elseif not espGenerators and obj.Name == "Generator" then
                    clearESP(obj)
                end
            end
        end
        task.wait(1)
    end
end)

ESPTab:CreateToggle({Name = "Killers ESP", CurrentValue = false, Callback = function(val) espKillers = val if not val then local killers = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Killers") if killers then for _, k in ipairs(killers:GetChildren()) do local h = k:FindFirstChild("ESP_Highlight") if h then h:Destroy() end end end end end})
ESPTab:CreateToggle({Name = "Survivors ESP", CurrentValue = false, Callback = function(val) espSurvivors = val if not val then local survivors = Workspace:FindFirstChild("Players") and Workspace.Players:FindFirstChild("Survivors") if survivors then for _, s in ipairs(survivors:GetChildren()) do local h = s:FindFirstChild("ESP_Highlight") if h then h:Destroy() end end end end end})
ESPTab:CreateToggle({Name = "Items ESP", CurrentValue = false, Callback = function(val) espItems = val if not val then local mapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") if mapFolder then for _, obj in ipairs(mapFolder:GetChildren()) do if obj.Name == "Medkit" or obj.Name == "BloxyCola" then local h = obj:FindFirstChild("ESP_Highlight") if h then h:Destroy() end local b = obj:FindFirstChild("ESP_Billboard") if b then b:Destroy() end end end end end end})
ESPTab:CreateToggle({Name = "Generators ESP", CurrentValue = false, Callback = function(val) espGenerators = val if not val then local mapFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Ingame") and workspace.Map.Ingame:FindFirstChild("Map") if mapFolder then for _, obj in ipairs(mapFolder:GetChildren()) do if obj.Name == "Generator" then local h = obj:FindFirstChild("ESP_Highlight") if h then h:Destroy() end end end end end end})

-- ================== Misc ==================
MiscTab:CreateButton({Name="Copy Discord Invite", Callback=function() pcall(function() setclipboard("https://discord.gg/baXMxMz5JZ") end) end})

-- ================== SOUND AUTO BLOCK SYSTEM (robust, facing checks removed) ==================
local soundHooks = {}     -- [sound] = { id = ..., hrp = ..., char = ..., playedConn = ..., propConn = ..., destroyConn = ... }
local soundBlockedUntil = {} -- [sound] = timestamp when we can block again (throttle)
local killerState = {}

local function extractNumericSoundId(sound)
    if not sound or not sound.SoundId then return nil end
    local sid = sound.SoundId
    sid = (type(sid) == "string") and sid or tostring(sid)
    local match = string.match(sid, "rbxassetid://(%d+)") or string.match(sid, "://(%d+)") or string.match(sid, "^(%d+)$")
    if match and #match > 0 then return match end
    local hash = string.match(sid, "[&%?]hash=([^&]+)")
    if hash then return "&hash=" .. hash end
    local path = string.match(sid, "rbxasset://sounds/.+")
    if path then return path end
    return nil
end

local KF = KillersFolder

local function getSoundWorldPosition(sound)
    if not sound then return nil, nil end
    local parent = sound.Parent
    if parent then
        if parent:IsA("BasePart") then return parent.Position, parent end
        if parent:IsA("Attachment") then
            local gp = parent.Parent
            if gp and gp:IsA("BasePart") then return gp.Position, gp end
        end
    end
    if KF and sound:IsDescendantOf(KF) then
        local root = parent or sound
        local found = root:FindFirstChildWhichIsA("BasePart", true)
        if found then return found.Position, found end
    end
    return nil, nil
end

local function getCharacterFromDescendant(inst)
    if not inst then return nil end
    local model = inst:FindFirstAncestorOfClass("Model")
    if model and model:FindFirstChildOfClass("Humanoid") then return model end
    return nil
end

local function isPointInsidePart(part, point)
    if not (part and point) then return false end
    local rel = part.CFrame:PointToObjectSpace(point)
    local half = part.Size * 0.5
    return math.abs(rel.X) <= half.X + 0.001 and math.abs(rel.Y) <= half.Y + 0.001 and math.abs(rel.Z) <= half.Z + 0.001
end

local function distSq(a,b) return (a.X-b.X)^2 + (a.Y-b.Y)^2 + (a.Z-b.Z)^2 end

local function _attemptForSound(sound, idParam, mode)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end

    local now = tick()
    if soundBlockedUntil[sound] and now < soundBlockedUntil[sound] then return end
    if now - lastLocalBlockTime < AUDIO_LOCAL_COOLDOWN then return end

    local id = idParam or (soundHooks[sound] and soundHooks[sound].id) or extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    if not cachedBlockBtn or not cachedCooldown or not cachedCharges then refreshUIRefs() end

    local myChar = lp and lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local hook = soundHooks[sound]
    local hrp = hook and hook.hrp
    local char = hook and hook.char

    if not hrp then
        local soundPos, soundPart = getSoundWorldPosition(sound)
        if not soundPart then return end
        char = getCharacterFromDescendant(soundPart)
        hrp = char and char:FindFirstChild("HumanoidRootPart")
        if hook then hook.char = char hook.hrp = hrp end
    end

    if not hrp then return end

    -- predicted position using velocity
    local v = hrp.Velocity or Vector3.new()
    local predictedPos = hrp.Position + v * AUDIO_PREDICT_DT
    if detectionRangeSq and distSq(predictedPos, myRoot.Position) > detectionRangeSq then
        if distSq(hrp.Position, myRoot.Position) > (detectionRange + 3)^2 then return end
    end

    -- verify world sound position & player
    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPart then return end
    local model = soundPart:FindFirstAncestorOfClass("Model")
    if not model then return end
    local humanoid = model:FindFirstChildWhichIsA("Humanoid")
    if not humanoid then return end
    local plr = Players:GetPlayerFromCharacter(model)
    if not plr or plr == lp then return end

    -- perform action depending on mode (facing checks removed)
    if mode == "Block" then
        fireGuiBlock()
    elseif mode == "Charge" then
        if cachedChargeBtn and cachedChargeBtn:FindFirstChild("CooldownTime") and cachedChargeBtn.CooldownTime.Text ~= "" then
            return
        end
        fireGuiCharge()
    elseif mode == "Clone" then
        if cachedCloneBtn and cachedCloneBtn:FindFirstChild("CooldownTime") and cachedCloneBtn.CooldownTime.Text ~= "" then
            return
        end
        fireGuiClone()
    end

    lastLocalBlockTime = now
    soundBlockedUntil[sound] = now + AUDIO_SOUND_THROTTLE
end

local function attemptBlockForSound(sound, idParam) return _attemptForSound(sound, idParam, "Block") end
local function attemptChargeForSound(sound, idParam) return _attemptForSound(sound, idParam, "Charge") end
local function attemptCloneForSound(sound, idParam) return _attemptForSound(sound, idParam, "Clone") end

-- BD / anti-flick parts approach
local function attemptBDParts(sound)
    if not autoBlockAudioOn then return end
    if not sound or not sound:IsA("Sound") then return end
    if not sound.IsPlaying then return end

    local id = extractNumericSoundId(sound)
    if not id or not autoBlockTriggerSounds[id] then return end

    local t = tick()
    if soundBlockedUntil[sound] and t < soundBlockedUntil[sound] then return end

    local myChar = lp and lp.Character
    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end

    local soundPos, soundPart = getSoundWorldPosition(sound)
    if not soundPos or not soundPart then return end

    local char = getCharacterFromDescendant(soundPart)
    local plr = char and Players:GetPlayerFromCharacter(char)
    if not plr or plr == lp then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    if antiFlickOn then
        local basePartSize = Vector3.new(5.5, 7.5, 8.5) * (blockPartsSizeMultiplier or 1)
        local count = math.max(1, antiFlickParts or 4)
        local base  = antiFlickBaseOffset or 2.5
        local step  = antiFlickOffsetStep or 0.2
        local lifeTime = 0.2

        task.spawn(function()
            local blocked = false
            task.wait(antiFlickDelay or 0)
            for i = 1, count do
                if not hrp or not myRoot then break end
                local dist = base + (i - 1) * step

                local st = killerState[char] or { vel = hrp.Velocity or Vector3.new(), angVel = 0 }
                local vel = st.vel or hrp.Velocity or Vector3.new()

                local forwardSpeed = vel:Dot(hrp.CFrame.LookVector)
                local lateralSpeed = vel:Dot(hrp.CFrame.RightVector)

                local pStrength = (type(predictionStrength) == "number" and predictionStrength) or 1
                local pTurn = (type(predictionTurnStrength) == "number" and predictionTurnStrength) or 1

                local forwardPredictRaw = forwardSpeed * PRED_SECONDS_FORWARD * pStrength
                local lateralPredictRaw = lateralSpeed * PRED_SECONDS_LATERAL * pStrength
                local turnLateralRaw    = st.angVel * ANG_TURN_MULTIPLIER * pTurn

                local forwardClamp = PRED_MAX_FORWARD * pStrength
                local lateralClamp = PRED_MAX_LATERAL * pStrength
                local turnClamp    = PRED_MAX_LATERAL * pTurn

                local forwardPredict = math.clamp(forwardPredictRaw, -forwardClamp, forwardClamp)
                local lateralPredict = math.clamp(lateralPredictRaw, -lateralClamp, lateralClamp)
                local turnLateral = math.clamp(turnLateralRaw, -turnClamp, turnClamp)

                local forwardDist = dist + forwardPredict

                local spawnPos = hrp.Position
                                + hrp.CFrame.LookVector * forwardDist
                                + hrp.CFrame.RightVector * (lateralPredict + turnLateral)

                local part = Instance.new("Part")
                part.Name = "AntiFlickZone"
                part.Size = basePartSize
                part.Transparency = 0.45
                part.Anchored = true
                part.CanCollide = false
                part.CFrame = CFrame.new(spawnPos, hrp.Position)
                part.BrickColor = BrickColor.new("Bright blue")
                part.Parent = workspace

                Debris:AddItem(part, lifeTime)

                if isPointInsidePart(part, myRoot.Position) then
                    blocked = true
                else
                    local touching = {}
                    pcall(function() touching = myRoot:GetTouchingParts() end)
                    for _, p in ipairs(touching) do
                        if p == part then blocked = true break end
                    end
                end

                if blocked then
                    if autoblocktype == "Block" then fireGuiBlock()
                    elseif autoblocktype == "Charge" then fireGuiCharge()
                    elseif autoblocktype == "7n7 Clone" then fireGuiClone() end

                    soundBlockedUntil[sound] = t + AUDIO_SOUND_THROTTLE
                    break
                end

                if stagger and stagger > 0 then task.wait(stagger) else task.wait(0) end
            end
        end)
    end
end

local function hookSound(sound)
    if not sound or not sound:IsA("Sound") then return end
    if soundHooks[sound] then return end

    local preId = extractNumericSoundId(sound)
    soundHooks[sound] = { id = preId, hrp = nil, char = nil }

    local function handleAttempt(snd, id)
        if not autoBlockAudioOn then return end
        if not antiFlickOn then
            local at = autoblocktype
            if at == "Block" then attemptBlockForSound(snd, id)
            elseif at == "Charge" then attemptChargeForSound(snd, id)
            elseif at == "7n7 Clone" then attemptCloneForSound(snd, id) end
        else
            attemptBDParts(snd)
        end
    end

    local playedConn = sound.Played:Connect(function() pcall(handleAttempt, sound, preId) end)
    local propConn = sound:GetPropertyChangedSignal("IsPlaying"):Connect(function() if sound.IsPlaying then pcall(handleAttempt, sound, preId) end end)

    local destroyConn
    destroyConn = sound.Destroying:Connect(function()
        if playedConn and playedConn.Connected then playedConn:Disconnect() end
        if propConn and propConn.Connected then propConn:Disconnect() end
        if destroyConn and destroyConn.Connected then destroyConn:Disconnect() end
        soundHooks[sound] = nil
        soundBlockedUntil[sound] = nil
    end)

    soundHooks[sound].playedConn = playedConn
    soundHooks[sound].propConn = propConn
    soundHooks[sound].destroyConn = destroyConn

    if sound.IsPlaying then task.spawn(function() pcall(handleAttempt, sound, preId) end) end
end

-- hook existing sounds under killers
pcall(function()
    for _, desc in ipairs(KillersFolder:GetDescendants()) do
        if desc:IsA("Sound") then pcall(hookSound, desc) end
    end
end)

-- hook future sounds under killers
KillersFolder.DescendantAdded:Connect(function(desc)
    if desc:IsA("Sound") then pcall(hookSound, desc) end
end)

-- ================== PREDICTIVE KILLER STATE UPDATER ==================
RunService.RenderStepped:Connect(function(dt)
    if dt <= 0 then return end
    local killers = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if not killers then return end
    for _, killer in ipairs(killers:GetChildren()) do
        if killer and killer.Parent then
            local hrp = killer:FindFirstChild("HumanoidRootPart")
            if hrp then
                local st = killerState[killer] or { prevPos = hrp.Position, prevLook = hrp.CFrame.LookVector, vel = Vector3.new(), angVel = 0 }
                local newVel = (hrp.Position - st.prevPos) / math.max(dt, 1e-6)
                st.vel = st.vel and st.vel:Lerp(newVel, SMOOTHING_LERP) or newVel
                local prevLook = st.prevLook or hrp.CFrame.LookVector
                local look = hrp.CFrame.LookVector
                local dot = math.clamp(prevLook:Dot(look), -1, 1)
                local angle = math.acos(dot)
                local crossY = prevLook:Cross(look).Y
                local angSign = (crossY >= 0) and 1 or -1
                local newAngVel = (angle / math.max(dt, 1e-6)) * angSign
                st.angVel = (st.angVel * (1 - SMOOTHING_LERP)) + (newAngVel * SMOOTHING_LERP)
                st.prevPos = hrp.Position
                st.prevLook = look
                killerState[killer] = st
            end
        end
    end
end)

-- ================== CONFIG SAVE ==================
Rayfield:LoadConfiguration()
