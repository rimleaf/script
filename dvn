--// Infinite Yield Loader (safe pcall)
pcall(function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/main/latest.lua'))()
end)
task.wait(0.1)

--[[ 
    Optimized full script (fixed aimbot selection):
    - Permanent attribute locks (event-driven)
    - Shielder shield remover
    - NPC-only ESP (white default, red when aimed)
    - Aimbot (hold LeftShift) with instant mouse-based snap (mousemoverel)
    - R6-aware target selection: gliding->legs, APU->head, torso priority if visible, else closest visible
    - Fixed: safe target-selection (no boolean<number comparisons), no undefined vars, safe iteration
    - Added: wallcheck and NPC-death checks for both aimbot and ESP
]]

----------------------------------------------------
--// Services & Locals
----------------------------------------------------
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local lp = Players.LocalPlayer
local cam = workspace.CurrentCamera

----------------------------------------------------
--// Config
----------------------------------------------------
local MAX_AIM_FOV = 50
local PREDICTION_STUDS = 2
local ATTRIBUTE_SCAN_INTERVAL = 2
local ATTRIBUTE_LISTENER_TAG = "_ModsAppliedOptimized"

local WeaponList = {
    "Aidkit","Akimbo","Barrier kit","BombCharge","Burst Rifle","DMR","Defibrillator",
    "ExplosiveBag","FAST","FuelCan","Grenade Launcher","Grenade Shell","Jetpack","Keycard",
    "LMG","Machete","Mastermind's Rifle","Motion Hider","PDC kit","RPG","Rifle","SMG","Shotgun",
    "Shovel","Tablet","Aerorig","Armour Peeler","Bolter","Combat Toolkit","Gift of Fire","Governor kit",
    "Gunslingers","Hallsweeper","Hallucinator kit","Handaxes","Harpoon Gun","Intraplanar Device",
    "Lifeline","Loose Trigger","MADS kit","Mercy Kill","Overcharger","PROXY","Pacemaker",
    "Parabolic Hydra","Rallying Cry","Recurve","Resuscitator","Rocket Stormer","Runner's Heat",
    "Shockwave Device","Sprinter's Streak","Steelforge","Stonehedge kit","Stonewall","Striker",
    "Terminal Velocity","Torqueblade","Twinface","Voltaic Impact","Ammo Box"
}

local DesiredAttributes = {
    Ammo = 999,
    FirerateMultiplier = 2,
    RefillRate = 200,
    HealthOnHit = 20,
    HealthOnKill = 200,
    ChainLimit = 20,
    ChainRadius = 200,
    ThrustSpeed = 270,
    Spread = 0,
    HeavySpread = 0,
    FullChargeTime = 0,
    MangledReviveTime = 0,
    RegularReviveTime = 0,
    Duration = 0,
    BurstFirerate = 999,
    BulletSpeed = 99999999999,
    Charges = 999,
    RechargeDuration = 0,
    MaxMADS = 999,
    ThrowAmmoCost = 0,
    CallDuration = 9999
}

local AttributeKeys = {}
for k,_ in pairs(DesiredAttributes) do table.insert(AttributeKeys, k) end
table.insert(AttributeKeys, "Firerate")

local function isWeaponNameAllowed(name)
    return table.find(WeaponList, name) ~= nil
end

----------------------------------------------------
--// Attribute enforcement (event-driven)
----------------------------------------------------
local function attachAttributeLock(obj)
    if not obj or not obj:IsA("Instance") then return end
    if not isWeaponNameAllowed(obj.Name) then return end
    if obj:FindFirstChild(ATTRIBUTE_LISTENER_TAG) then return end

    local tag = Instance.new("BoolValue")
    tag.Name = ATTRIBUTE_LISTENER_TAG
    tag.Parent = obj

    -- Firerate special handling
    if obj:GetAttribute("Firerate") ~= nil then
        local ok, orig = pcall(function() return obj:GetAttribute("Firerate") end)
        local base = (ok and type(orig)=="number") and orig or tonumber(orig) or 0
        local target = base * (DesiredAttributes.FirerateMultiplier or 1)
        pcall(function() obj:SetAttribute("Firerate", target) end)
        obj:GetAttributeChangedSignal("Firerate"):Connect(function()
            pcall(function() obj:SetAttribute("Firerate", target) end)
        end)
    end

    for _, attrName in ipairs(AttributeKeys) do
        if attrName == "Firerate" then
            -- handled above
        else
            if obj:GetAttribute(attrName) ~= nil then
                local desired = DesiredAttributes[attrName]
                if desired ~= nil then
                    pcall(function() obj:SetAttribute(attrName, desired) end)
                    obj:GetAttributeChangedSignal(attrName):Connect(function()
                        pcall(function() obj:SetAttribute(attrName, desired) end)
                    end)
                end
            end
        end
    end
end

local function scanAndAttach(container)
    if not container then return end
    for _, child in ipairs(container:GetDescendants()) do
        attachAttributeLock(child)
    end
end

-- initial attach
task.spawn(function()
    task.wait(0.1)
    if lp then
        local bp = lp:FindFirstChildOfClass("Backpack")
        if bp then scanAndAttach(bp) end
        if lp.Character then scanAndAttach(lp.Character) end
    end
    for _, v in ipairs(Workspace:GetChildren()) do attachAttributeLock(v) end
end)

-- event hooks
if lp then
    lp:WaitForChild("Backpack").ChildAdded:Connect(function(child) task.wait(0.05); attachAttributeLock(child) end)
    lp.CharacterAdded:Connect(function(char)
        scanAndAttach(char)
        char.ChildAdded:Connect(function(c) task.wait(0.05); attachAttributeLock(c) end)
    end)
    if lp.Character then
        lp.Character.ChildAdded:Connect(function(c) task.wait(0.05); attachAttributeLock(c) end)
    end
end

Workspace.DescendantAdded:Connect(function(desc)
    if desc and isWeaponNameAllowed(desc.Name) then
        task.wait(0.05)
        attachAttributeLock(desc)
    end
end)

task.spawn(function()
    while task.wait(ATTRIBUTE_SCAN_INTERVAL) do
        if lp then
            local bp = lp:FindFirstChildOfClass("Backpack")
            if bp then scanAndAttach(bp) end
            if lp.Character then scanAndAttach(lp.Character) end
        end
        for _, v in ipairs(Workspace:GetChildren()) do attachAttributeLock(v) end
    end
end)

----------------------------------------------------
--// Shielder Shield Remover
----------------------------------------------------
local function handleModel_shielder(model)
    if not model or not model:IsA("Model") then return end
    if model.Name == "Shielder" or model.Name == "EscortShielder" then
        local shield = model:FindFirstChild("Shield")
        if shield then pcall(function() shield:Destroy() end) end
    end
end

for _, m in ipairs(Workspace:GetChildren()) do pcall(function() handleModel_shielder(m) end) end
Workspace.ChildAdded:Connect(function(child)
    if child and child:IsA("Model") then
        handleModel_shielder(child)
        child.DescendantAdded:Connect(function(d)
            if d and d.Name == "Shield" then task.wait(0.05); handleModel_shielder(child) end
        end)
    end
end)

----------------------------------------------------
--// NPC tracking cache (only NPCs)
-- Efficient cache used by the lean aimbot below
----------------------------------------------------
local function isNPCModel(m)
    if not m or not m:IsA("Model") then return false end
    if Players:FindFirstChild(m.Name) then return false end
    if not m:FindFirstChild("Humanoid") then return false end
    return true
end

local npcCache = {}     -- array of entries { model=model, aimPart=part, humanoid=hum }
local npcIndex = {}     -- map model -> index in npcCache

local function getBestDefaultAimPart(model)
    if not model then return nil end
    if model.Name == "APU" then
        local h = model:FindFirstChild("Head")
        if h and h:IsA("BasePart") then return h end
    end
    local torso = model:FindFirstChild("Torso")
    if torso and torso:IsA("BasePart") then return torso end
    local head = model:FindFirstChild("Head")
    if head and head:IsA("BasePart") then return head end
    local hroot = model:FindFirstChild("HumanoidRootPart")
    if hroot and hroot:IsA("BasePart") then return hroot end
    local left = model:FindFirstChild("Left Leg")
    if left and left:IsA("BasePart") then return left end
    local right = model:FindFirstChild("Right Leg")
    if right and right:IsA("BasePart") then return right end
    return nil
end

local function removeFromCache(model)
    local i = npcIndex[model]
    if not i then return end
    local last = table.remove(npcCache)
    npcIndex[model] = nil
    if last and last.model ~= model then
        npcCache[i] = last
        npcIndex[last.model] = i
    end
end

local function addToCache(model)
    if not isNPCModel(model) then return end
    if npcIndex[model] then return end
    local hum = model:FindFirstChild("Humanoid")
    if not hum then return end
    local aim = getBestDefaultAimPart(model)
    if not aim then return end
    local entry = { model = model, aimPart = aim, humanoid = hum }
    table.insert(npcCache, entry)
    npcIndex[model] = #npcCache

    hum.Died:Connect(function()
        removeFromCache(model)
        local hl = model:FindFirstChild("ESP_Highlight")
        if hl then pcall(function() hl:Destroy() end) end
        if currentHighlighted == model then currentHighlighted = nil end
    end)
    model.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removeFromCache(model)
        end
    end)
end

-- initial population
for _, child in ipairs(Workspace:GetChildren()) do
    if isNPCModel(child) then
        pcall(function() addToCache(child) end)
    end
end

Workspace.ChildAdded:Connect(function(child)
    if isNPCModel(child) then
        task.delay(0.02, function() pcall(function() addToCache(child) end) end)
    end
end)

Workspace.DescendantAdded:Connect(function(desc)
    local parent = desc and desc.Parent
    if parent and isNPCModel(parent) then
        task.delay(0.02, function() pcall(function() addToCache(parent) end) end)
    end
end)

Workspace.ChildRemoved:Connect(function(child)
    if npcIndex[child] then removeFromCache(child) end
end)

----------------------------------------------------
--// Utility: NPC alive check
----------------------------------------------------
local function isNPCAlive(model)
    if not model or not model:IsA("Model") then return false end
    local hum = model:FindFirstChild("Humanoid")
    if not hum then return false end
    local ok, health = pcall(function() return hum.Health end)
    return ok and type(health) == "number" and health > 0
end

----------------------------------------------------
--// ESP manager (NPC-only) - respects alive state
----------------------------------------------------
local function ensureHighlightFor(model)
    if not model or not model:IsA("Model") then return nil end
    if not isNPCAlive(model) then
        local prev = model:FindFirstChild("ESP_Highlight")
        if prev then pcall(function() prev:Destroy() end) end
        return nil
    end
    if model:FindFirstChild("ESP_Highlight") then return model.ESP_Highlight end
    local hl = Instance.new("Highlight")
    hl.Name = "ESP_Highlight"
    hl.Adornee = model
    hl.FillColor = Color3.fromRGB(255,255,255)
    hl.OutlineColor = Color3.fromRGB(255,255,255)
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.Parent = model
    return hl
end

for _, entry in ipairs(npcCache) do
    pcall(function() ensureHighlightFor(entry.model) end)
end

Workspace.ChildAdded:Connect(function(child)
    if npcIndex[child] then task.delay(0.05, function() ensureHighlightFor(child) end) end
end)

----------------------------------------------------
--// R6-aware targeting helpers (kept lightweight)
----------------------------------------------------
local function isPlayerGliding()
    if not lp or not lp.Character then return false end
    for _, tool in ipairs(lp.Character:GetChildren()) do
        if tool:IsA("Tool") and (tool.Name == "Jetpack" or tool.Name == "Terminal Velocity") then
            local ok, val = pcall(function() return tool:GetAttribute("Gliding") end)
            if ok and val == true then return true end
        end
    end
    return false
end

local function findClosestLeg(model)
    if not model then return nil end
    local camPos = cam and cam.CFrame.Position or workspace.CurrentCamera.CFrame.Position
    local left = model:FindFirstChild("Left Leg")
    local right = model:FindFirstChild("Right Leg")
    if left and right then
        local dl = (left.Position - camPos).Magnitude
        local dr = (right.Position - camPos).Magnitude
        return (dl < dr) and left or right
    end
    return left or right
end

local function isPartVisible(part, model)
    if not part or not part:IsA("BasePart") then return false end
    local origin = cam and cam.CFrame.Position or workspace.CurrentCamera.CFrame.Position
    local dir = part.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { lp.Character }
    params.IgnoreWater = true
    local result = workspace:Raycast(origin, dir, params)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(model)
end

local function findClosestVisiblePart(model)
    if not model then return nil end
    local names = {"Torso","Head","Left Leg","Right Leg","Left Arm","Right Arm","HumanoidRootPart"}
    local best, bestD = nil, math.huge
    local camPos = cam and cam.CFrame.Position or workspace.CurrentCamera.CFrame.Position
    for _, n in ipairs(names) do
        local p = model:FindFirstChild(n)
        if p and p:IsA("BasePart") and isPartVisible(p, model) then
            local d = (p.Position - camPos).Magnitude
            if d < bestD then bestD = d; best = p end
        end
    end
    return best
end

-- Enhanced getAimPart: respects DMR/Gift of Fire head priority and original logic
local function getAimPart(model)
    if not model or not model:IsA("Model") then return nil end
    if Players:FindFirstChild(model.Name) then return nil end

    -- If holding DMR or Gift of Fire, prioritize head
    if lp and lp.Character then
        local tool = lp.Character:FindFirstChildOfClass("Tool")
        if tool and (tool.Name == "DMR" or tool.Name == "Gift of Fire") then
            local head = model:FindFirstChild("Head")
            if head and head:IsA("BasePart") then
                return head
            end
        end
    end

    if isPlayerGliding() then
        local leg = findClosestLeg(model)
        if leg then return leg end
    end

    if model.Name == "APU" then
        local h = model:FindFirstChild("Head")
        if h and h:IsA("BasePart") then return h end
    end

    local torso = model:FindFirstChild("Torso")
    if torso and torso:IsA("BasePart") and isPartVisible(torso, model) then return torso end

    local vis = findClosestVisiblePart(model)
    if vis then return vis end

    return torso or model:FindFirstChild("Head") or model:FindFirstChild("HumanoidRootPart")
end

----------------------------------------------------
--// Lean selection helper used by aimbot
-- returns bestEntry (from npcCache) and screenPos (Vector3)
----------------------------------------------------
local COS_FOV = math.cos(math.rad(MAX_AIM_FOV))

local function hasLineOfSight(part, model)
    if not part then return false end
    local origin = cam.CFrame.Position
    local dir = part.Position - origin
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = { lp.Character }
    params.IgnoreWater = true
    local result = workspace:Raycast(origin, dir, params)
    if not result then return true end
    return result.Instance and result.Instance:IsDescendantOf(model)
end

local function getBestTarget()
    local camPos = cam.CFrame.Position
    local camForward = cam.CFrame.LookVector
    local mousePos = UserInputService:GetMouseLocation()
    local bestEntry = nil
    local bestScreenDist = math.huge
    local bestScreenPos = nil

    for i = 1, #npcCache do
        local e = npcCache[i]
        if e and e.model and e.model.Parent and e.humanoid and e.humanoid.Health > 0 then
            -- refresh aimPart if needed
            if not e.aimPart or not e.aimPart.Parent then
                e.aimPart = getAimPart(e.model)
                if not e.aimPart then
                    -- skip if no part found
                    goto continue_getBest
                end
            end

            local part = e.aimPart
            if part and part.Parent then
                local toPart = part.Position - camPos
                local mag = toPart.Magnitude
                if mag > 0 then
                    local dot = camForward:Dot(toPart / mag)
                    if dot >= COS_FOV then
                        local screenPos3, onScreen = cam:WorldToViewportPoint(part.Position)
                        if onScreen and screenPos3.Z > 0 then
                            local dx = screenPos3.X - mousePos.X
                            local dy = screenPos3.Y - mousePos.Y
                            local sd = math.sqrt(dx*dx + dy*dy)
                            if sd < bestScreenDist and sd <= MAX_AIM_FOV then
                                bestEntry = e
                                bestScreenDist = sd
                                bestScreenPos = screenPos3
                            end
                        end
                    end
                end
            end
        end
        ::continue_getBest::
    end

    return bestEntry, bestScreenPos
end

----------------------------------------------------
--// Highlighting: change only on target switch (white <-> red)
----------------------------------------------------
local currentHighlighted = nil

local function setHighlightFor(target)
    if currentHighlighted == target then return end
    if currentHighlighted and currentHighlighted.Parent then
        local hl = currentHighlighted:FindFirstChild("ESP_Highlight")
        if hl then
            hl.FillColor = Color3.fromRGB(255,255,255)
            hl.OutlineColor = Color3.fromRGB(255,255,255)
        end
    end
    currentHighlighted = target
    if currentHighlighted and currentHighlighted.Parent and isNPCAlive(currentHighlighted) then
        local hl = ensureHighlightFor(currentHighlighted)
        if hl then
            hl.FillColor = Color3.fromRGB(255,0,0)
            hl.OutlineColor = Color3.fromRGB(255,0,0)
        end
    else
        currentHighlighted = nil
    end
end

----------------------------------------------------
--// Keep aimPart references fresh in a cheap loop
----------------------------------------------------
RunService.Heartbeat:Connect(function()
    for i = 1, #npcCache do
        local e = npcCache[i]
        if e and e.model and e.model.Parent then
            if not e.aimPart or not e.aimPart.Parent then
                local newPart = getAimPart(e.model)
                if newPart then e.aimPart = newPart end
            end
        end
    end
end)

----------------------------------------------------
--// Hold-to-aim (LeftShift) + instant mouse-based snap
----------------------------------------------------
local aimbotActive = false

UserInputService.InputBegan:Connect(function(input, _)
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.LeftShift then
        aimbotActive = true
    end
end)

UserInputService.InputEnded:Connect(function(input, _)
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.LeftShift then
        aimbotActive = false
        setHighlightFor(nil)
    end
end)

-- Main loop: RenderStepped for precise, per-frame mouse snaps
RunService.RenderStepped:Connect(function()
    cam = workspace.CurrentCamera
    if not aimbotActive then return end

    -- clean and ensure ESP highlights for alive NPCs only
    for i = #npcCache, 1, -1 do
        local entry = npcCache[i]
        if not entry or not entry.model or not entry.model.Parent or not entry.humanoid then
            if entry and entry.model then
                removeFromCache(entry.model)
            end
        else
            if not isNPCAlive(entry.model) then
                local prev = entry.model:FindFirstChild("ESP_Highlight")
                if prev then pcall(function() prev:Destroy() end) end
                removeFromCache(entry.model)
                if currentHighlighted == entry.model then currentHighlighted = nil end
            else
                if not entry.model:FindFirstChild("ESP_Highlight") then
                    ensureHighlightFor(entry.model)
                end
            end
        end
    end

    -- select best target
    local bestEntry, bestScreenPos = getBestTarget()
    if not bestEntry or not bestEntry.model or not bestEntry.aimPart then
        setHighlightFor(nil)
        return
    end

    local aimPart = bestEntry.aimPart
    if not hasLineOfSight(aimPart, bestEntry.model) then
        setHighlightFor(nil)
        return
    end

    setHighlightFor(bestEntry.model)

    -- Predict slight movement
    local predicted = aimPart.Position
    local vel = aimPart.Velocity or Vector3.new()
    if vel.Magnitude > 1 then
        predicted = predicted + vel.Unit * PREDICTION_STUDS
    end

    -- Convert predicted world position to screen position (update bestScreenPos if nil)
    local screenPos, onScreen = cam:WorldToViewportPoint(predicted)
    if not onScreen or screenPos.Z <= 0 then
        setHighlightFor(nil)
        return
    end

    -- Instant mouse snap using mousemoverel. If unavailable, fallback to camera snap.
    local mousePos = UserInputService:GetMouseLocation()
    local dx = screenPos.X - mousePos.X
    local dy = screenPos.Y - mousePos.Y

    pcall(function()
        if type(mousemoverel) == "function" then
            mousemoverel(dx, dy)
        else
            -- fallback: instant camera snap
            local camPos = cam.CFrame.Position
            local newCFrame = CFrame.new(camPos, predicted)
            pcall(function() Workspace.CurrentCamera.CFrame = newCFrame end)
        end
    end)
end)

-- confirmation
task.spawn(function() task.wait(0.4); if lp then print("Instant mouse-based aimbot + NPC ESP loaded (hold LeftShift).") end end)
