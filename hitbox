-- ==============================================================
--  SHIFT-LOCK SMOOTH AIMBOT (Roblox Lua)
--  Paste this over your original script â€“ everything else stays the same
-- ==============================================================

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Rep = game:GetService("ReplicatedStorage")
local client = Players.LocalPlayer

repeat task.wait() until client and client.Character
local char = client.Character
local humanoid = char:WaitForChild("Humanoid")
local root = char:WaitForChild("HumanoidRootPart")

client.CharacterAdded:Connect(function(newChar)
    char = newChar
    humanoid = char:WaitForChild("Humanoid")
    root = char:WaitForChild("HumanoidRootPart")
end)

-- ==============================================================
--  ORIGINAL EXTEND HITBOX (unchanged)
-- ==============================================================
local function ExtendHitbox(studs)
    RunService.Heartbeat:Wait()
    while not (
        client.Character
        and client.Character.Parent
        and client.Character:FindFirstChild("HumanoidRootPart")
        and client.Character.HumanoidRootPart.Parent
    ) do
        RunService.Heartbeat:Wait()
    end
    local hrp = client.Character.HumanoidRootPart
    local originalVel = hrp.AssemblyLinearVelocity
    local look = hrp.CFrame.LookVector
    hrp.AssemblyLinearVelocity = look * studs
    RunService.RenderStepped:Wait()
    if client.Character
    and client.Character.Parent
    and client.Character:FindFirstChild("HumanoidRootPart")
    and client.Character.HumanoidRootPart.Parent then
        client.Character.HumanoidRootPart.AssemblyLinearVelocity = originalVel
    end
end

-- ==============================================================
--  REMOTE & SPRINT DETECTION (unchanged)
-- ==============================================================
local Remote = Rep:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
local Sprinting = Rep:WaitForChild("Systems"):WaitForChild("Character"):WaitForChild("Game"):WaitForChild("Sprinting")
local SprintModule = require(Sprinting)
local prevStamina = nil
local isSprinting = false

RunService.Heartbeat:Connect(function()
    local currStamina = SprintModule.Stamina
    isSprinting = (prevStamina ~= nil and currStamina < prevStamina)
    prevStamina = currStamina
end)

local function getAbilityName(v)
    if typeof(v) == "buffer" then return buffer.tostring(v) end
    return v
end
local function cleanName(name) return tostring(name):gsub("\"", "") end

-- ==============================================================
--  AIMBOT SETTINGS
-- ==============================================================
local Aimbot = {
    enabled = true,
    minHealth = 200,
    range = 120,
    preferBack = false,
    meleeLockDuration = 0.45,
    meleePredict = true,
    meleePredictStuds = 3,          -- fixed studs ahead
    deadTargetGrace = 0.5,
    smoothFactor = 0.2,            -- 0 = instant, 1 = no movement (lerp alpha)
    returnSmoothFactor = 0.25      -- how fast we snap back to shift-lock
}

-- ==============================================================
--  DEAD TARGET TRACKING (unchanged)
-- ==============================================================
local lockedTarget = nil
local lockStartTime = 0

local function findAimbotTarget()
    local closest, closestDist = nil, math.huge
    local now = os.clock()

    if lockedTarget and lockedTarget.Parent then
        if (now - lockStartTime) <= Aimbot.deadTargetGrace then
            if lockedTarget.Character and lockedTarget.Character.Parent
               and lockedTarget.Character:FindFirstChild("HumanoidRootPart") then
                return lockedTarget
            end
        end
        lockedTarget = nil
    end

    if not client.Character or not client.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = client.Character.HumanoidRootPart.Position

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= client and p.Character and p.Character.Parent then
            local h = p.Character:FindFirstChild("Humanoid")
            local hrp = p.Character:FindFirstChild("HumanoidRootPart")
            if h and hrp and h.Health and h.Health < Aimbot.minHealth then
                local dist = (hrp.Position - myPos).Magnitude
                if dist < closestDist and dist <= Aimbot.range then
                    closest, closestDist = p, dist
                end
            end
        end
    end

    if closest then
        lockedTarget, lockStartTime = closest, now
    end
    return closest
end

-- ==============================================================
--  PREDICTION (unchanged)
-- ==============================================================
local function getMeleePredictedPosition(targetHRP)
    if not Aimbot.meleePredict then return targetHRP.Position end
    local vel = targetHRP.AssemblyLinearVelocity
    if vel.Magnitude < 0.1 then return targetHRP.Position end
    return targetHRP.Position + vel.Unit * Aimbot.meleePredictStuds
end

-- ==============================================================
--  SMOOTH AIM FUNCTION
-- ==============================================================
local shiftLockCFrame = nil          -- where shift-lock was pointing when we started
local returning = false
local returnStart = 0

local function aimAtMeleeTargetSmooth(target)
    if not target or not target.Character or not target.Character:FindFirstChild("HumanoidRootPart") then return end
    local myHRP = client.Character.HumanoidRootPart
    local targetHRP = target.Character.HumanoidRootPart

    local predicted = getMeleePredictedPosition(targetHRP)
    local lookDir = Aimbot.preferBack and -targetHRP.CFrame.LookVector or targetHRP.CFrame.LookVector
    local aimPoint = predicted + lookDir * 2

    -- Desired CFrame (look at the point, keep Y level)
    local desired = CFrame.lookAt(myHRP.Position, aimPoint)

    -- Lerp toward it
    myHRP.CFrame = myHRP.CFrame:lerp(desired, Aimbot.smoothFactor)
end

-- ==============================================================
--  SHIFT-LOCK DETECTION
-- ==============================================================
local function isShiftLockEnabled()
    -- Roblox's built-in flag (works for both core shift-lock and custom UI)
    return client.DevEnableMouseLock or (client.PlayerGui:FindFirstChild("ShiftLock") and client.PlayerGui.ShiftLock.Enabled)
end

-- ==============================================================
--  MAIN REMOTE HANDLER (enhanced)
-- ==============================================================
Remote.OnClientEvent:Connect(function(action, data)
    if action ~= "UseActorAbility" then return end
    if typeof(data) ~= "table" or not data[1] then return end

    local abilityName = cleanName(getAbilityName(data[1]))

    -- ==== MELEE ABILITIES ====
    if abilityName == "Carving Slash" or abilityName == "Slash"
        or abilityName == "Stab" or abilityName == "Punch" then

        -- ---- Hitbox extend (sprint) ----
        local hbStart = os.clock()
        local hbConn
        hbConn = RunService.Heartbeat:Connect(function()
            if os.clock() - hbStart >= 1.5 then hbConn:Disconnect() return end
            if isSprinting then ExtendHitbox(40) end
        end)

        -- ---- AIMBOT ----
        if not Aimbot.enabled then return end

        local aimStart = os.clock()
        local aimConn

        -- 1. Capture shift-lock orientation (if active)
        if isShiftLockEnabled() then
            shiftLockCFrame = root.CFrame
            humanoid.AutoRotate = false
        else
            shiftLockCFrame = nil
            humanoid.AutoRotate = false
        end

        returning = false

        aimConn = RunService.Heartbeat:Connect(function()
            local elapsed = os.clock() - aimStart

            -- ---- AIM PHASE ----
            if elapsed < Aimbot.meleeLockDuration then
                local target = findAimbotTarget()
                if target then
                    aimAtMeleeTargetSmooth(target)
                end
                return
            end

            -- ---- RETURN PHASE (smooth snap back) ----
            if not returning then
                returning = true
                returnStart = os.clock()
                aimConn:Disconnect()
                humanoid.AutoRotate = true   -- let Roblox handle rotation again
            end

            local returnElapsed = os.clock() - returnStart
            if returnElapsed > 0.4 then
                -- done
                shiftLockCFrame = nil
                return
            end

            if shiftLockCFrame then
                root.CFrame = root.CFrame:lerp(shiftLockCFrame, Aimbot.returnSmoothFactor)
            end
        end)
    end
end)
