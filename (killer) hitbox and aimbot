-- Services
local srvPlayers = game:GetService("Players")
local srvRun = game:GetService("RunService")

local client = srvPlayers.LocalPlayer
repeat task.wait() until client and client.Character

local char = client.Character
local humanoid = char:WaitForChild("Humanoid")
local animator = humanoid:WaitForChild("Animator")
local root = char:WaitForChild("HumanoidRootPart")

client.CharacterAdded:Connect(function(newChar)
	char = newChar
	humanoid = char:WaitForChild("Humanoid")
	animator = humanoid:WaitForChild("Animator")
	root = char:WaitForChild("HumanoidRootPart")
end)

-- Raw IDs (any format) -> we'll normalize to digits only
local attackIdsRaw = {
	["rbxassetid://83829782357897"] = true,
	["rbxassetid://126830014841198"] = true,
	["rbxassetid://126355327951215"] = true,
	["rbxassetid://105458270463374"] = true,
	["rbxassetid://18885909645"] = true,
	["rbxassetid://94162446513587"] = true,
	["rbxassetid://93069721274110"] = true,
	["rbxassetid://97433060861952"] = true,
	["rbxassetid://121293883585738"] = true,
	["rbxassetid://92173139187970"] = true,
	["rbxassetid://125403313786645"] = true,
	["rbxassetid://81639435858902"] = true,
	["rbxassetid://120112897026015"] = true,
	["rbxassetid://82113744478546"] = true,
	["rbxassetid://118298475669935"] = true,
	["rbxassetid://126681776859538"] = true,
	["rbxassetid://109667959938617"] = true,
	["rbxassetid://74707328554358"] = true,
	["rbxassetid://133336594357903"] = true,
	["rbxassetid://70371667919898"] = true,
	["rbxassetid://131543461321709"] = true,
	["rbxassetid://136323728355613"] = true,
	["rbxassetid://109230267448394"] = true
}

-- Prediction function
local function getPredictedPosition(hrp, hum)
	if not hrp or not hum then return hrp and hrp.Position or nil end

	local moveDir = hum.MoveDirection
	local velocity = hrp.Velocity
	local predictionTime = 0.45

	if moveDir.Magnitude < 1 and velocity.Magnitude < 1 then
		return hrp.Position
	end

	local offset
	if moveDir.Magnitude > 0.1 then
		offset = moveDir.Unit * hum.WalkSpeed * predictionTime
	else
		offset = velocity * predictionTime
	end

	if offset.Magnitude > 6 then
		offset = offset.Unit * 6
	end

	return hrp.Position + offset
end

-- Get nearest Survivor
local function getClosestSurvivor()
	local folder = workspace.Players:FindFirstChild("Survivors")
	if not folder then return nil end

	local closest, dist = nil, math.huge
	for _, model in ipairs(folder:GetChildren()) do
		local hrp = model:FindFirstChild("HumanoidRootPart")
		local hum = model:FindFirstChild("Humanoid")
		if hrp and hum and hum.Health > 0 then
			local d = (hrp.Position - root.Position).Magnitude
			if d < dist then
				closest, dist = model, d
			end
		end
	end

	-- keep targeting the last one for 0.2s even if they die
	if closest then
		task.delay(0.2, function()
			if closest and closest:FindFirstChild("Humanoid") and closest.Humanoid.Health <= 1 then
				closest = nil
			end
		end)
	end

	return closest
end


-- Active aimbot state
local aimbotTrack = nil
local aimbotEnd = 0

-- Keeps your behavior intact
local function ExtendHitbox(studs)
	game:GetService("RunService").Heartbeat:Wait()

	-- character and humanoidrootpart exists check
	while not (
		game:GetService("Players").LocalPlayer.Character
		and game:GetService("Players").LocalPlayer.Character.Parent
		and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent
	) do
		game:GetService("RunService").Heartbeat:Wait()
	end

	-- save
	local hrp = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart
	local velocity = hrp.AssemblyLinearVelocity
	local lookvec = hrp.CFrame.LookVector

	-- start extending
	hrp.AssemblyLinearVelocity += (lookvec * studs)
	game:GetService("RunService").RenderStepped:Wait()
	-- stop and restore origin of velocity
	if (
		game:GetService("Players").LocalPlayer.Character
		and game:GetService("Players").LocalPlayer.Character.Parent
		and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		and game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.Parent
	) then
		game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = velocity
	end
end

local aimbotEnd = 0

local function normalizeId(id)
	if not id then return nil end
	-- Extract only digits
	local digits = string.match(id, "%d+")
	return digits
end

srvRun.Heartbeat:Connect(function()
	if not root or not humanoid then return end

	-- Check if an attack animation is currently playing
	local isAttacking = false
	for _, track in humanoid:GetPlayingAnimationTracks() do
		local animId = track.Animation and track.Animation.AnimationId
		local normId = normalizeId(animId)
		if normId and attackIdsRaw["rbxassetid://" .. normId] and (track.TimePosition / track.Length < 0.75) then
			isAttacking = true
			break
		end
	end

	-- If attack detected, extend timer
	if isAttacking then
		aimbotEnd = tick() + 0.1
		ExtendHitbox(30)
	end

	-- Only run while timer is active
	if tick() <= aimbotEnd then

		local target = getClosestSurvivor()
		if target then
			local thrp = target:FindFirstChild("HumanoidRootPart")
			local thum = target:FindFirstChild("Humanoid")
			if thrp and thum then
				local predicted = getPredictedPosition(thrp, thum) or thrp.Position
				local fromPos = root.Position
				local dir = predicted - fromPos
				if dir.Magnitude > 1e-3 then
					root.CFrame = CFrame.lookAt(fromPos, fromPos + dir)
				end
			end
		end
	end
end)
wait(0.1)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer
local camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local shiftlockEnabled = false
local connection

local function setShiftlock(state)
    if not lp then return end
    local playerModule = require(lp:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule"))
    local controls = playerModule:GetControls()
    local mouseLockController = controls:GetMouseLockController()
    local wasShiftLocked = mouseLockController:IsMouseLocked()

    if state then
        -- only force lock if not already locked
        if not wasShiftLocked then
            mouseLockController:EnableMouseLock()
        end

        if connection then
            connection:Disconnect()
            connection = nil
        end

        connection = RunService.RenderStepped:Connect(function()
            local character = lp.Character
            local root = character and character:FindFirstChild("HumanoidRootPart")
            if root then
                local camCF = camera.CFrame
                root.CFrame = CFrame.new(root.Position, Vector3.new(
                    camCF.LookVector.X + root.Position.X,
                    root.Position.Y,
                    camCF.LookVector.Z + root.Position.Z
                ))
            end
        end)
    else
        if connection then
            connection:Disconnect()
            connection = nil
        end

        -- only disable if the player wasn't using shiftlock before override
        if not wasShiftLocked then
            mouseLockController:DisableMouseLock()
        end

        UserInputService.MouseBehavior = Enum.MouseBehavior.Default
        camera.CameraType = Enum.CameraType.Custom
    end
end


local chargeAnimIds = {
    "117058860640843"
}

-- Override speed (same as your noli script)
local ORIGINAL_DASH_SPEED = 80

-- Toggle / runtime state
local controlChargeEnabled = true
local controlChargeActive = false
local overrideConnection = nil
local detectorChargeIds = (type(chargeAnimIds) == "table" and chargeAnimIds) or {}

-- Save/restore for humanoid original values
local savedHumanoidState = {}

local function getHumanoid()
    if not lp or not lp.Character then return nil end
    return lp.Character:FindFirstChildOfClass("Humanoid")
end

local function saveHumState(hum)
    if not hum then return end
    if savedHumanoidState[hum] then return end
    local s = {}
    pcall(function()
        s.WalkSpeed = hum.WalkSpeed
        -- support either JumpPower or JumpHeight
        local ok, _ = pcall(function() s.JumpPower = hum.JumpPower end)
        if not ok then
            pcall(function() s.JumpPower = hum.JumpHeight end)
        end
        -- AutoRotate might not exist on all Humanoids; try to capture if possible
        local ok2, ar = pcall(function() return hum.AutoRotate end)
        if ok2 then s.AutoRotate = ar end
        s.PlatformStand = hum.PlatformStand
    end)
    savedHumanoidState[hum] = s
end

local function restoreHumState(hum)
    if not hum then return end
    local s = savedHumanoidState[hum]
    if not s then return end
    pcall(function()
        if s.WalkSpeed ~= nil then hum.WalkSpeed = s.WalkSpeed end
        if s.JumpPower ~= nil then
            local ok, _ = pcall(function() hum.JumpPower = s.JumpPower end)
            if not ok then pcall(function() hum.JumpHeight = s.JumpPower end) end
        end
        if s.AutoRotate ~= nil then pcall(function() hum.AutoRotate = s.AutoRotate end) end
        if s.PlatformStand ~= nil then hum.PlatformStand = s.PlatformStand end
    end)
    savedHumanoidState[hum] = nil
end

-- Start the override (forces dash movement similar to noli void rush)
local function startOverride()
    if controlChargeActive then return end
    local hum = getHumanoid()
    if not hum then return end

    controlChargeActive = true
    saveHumState(hum)

    -- Make sure humanoid is set to dash state
    pcall(function()
        hum.WalkSpeed = ORIGINAL_DASH_SPEED
        hum.AutoRotate = false
    end)
    
    setShiftlock(true)
    
    -- RenderStepped connection to force forward movement every frame (like your noli function)
    overrideConnection = RunService.RenderStepped:Connect(function()
        local humanoid = getHumanoid()
        local rootPart = humanoid and humanoid.Parent and humanoid.Parent:FindFirstChild("HumanoidRootPart")
        if not humanoid or not rootPart then return end

        -- ensure speed + autorotate each frame (helps if some other code fights it)
        pcall(function()
            humanoid.WalkSpeed = ORIGINAL_DASH_SPEED
            humanoid.AutoRotate = false
        end)

        local direction = rootPart.CFrame.LookVector
        local horizontal = Vector3.new(direction.X, 0, direction.Z)
        if horizontal.Magnitude > 0 then
            humanoid:Move(horizontal.Unit)
        else
            humanoid:Move(Vector3.new(0,0,0))
        end
    end)
end

-- Stop the override and restore humanoid state
local function stopOverride()
    if not controlChargeActive then return end
    controlChargeActive = false

    -- disconnect override loop
    if overrideConnection then
        pcall(function() overrideConnection:Disconnect() end)
        overrideConnection = nil
    end

    setShiftlock(false)

    -- restore humanoid fields
    local hum = getHumanoid()
    if hum then
        pcall(function()
            -- restore saved values if present
            restoreHumState(hum)
            -- ensure we stop movement
            hum:Move(Vector3.new(0,0,0))
        end)
    end
end

-- Internal detection: look for playing anim tracks that match charge IDs or custom ID
local function detectChargeAnimation()
    local hum = getHumanoid()
    if not hum then return false end
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        local ok, animId = pcall(function()
            return tostring(track.Animation and track.Animation.AnimationId or ""):match("%d+")
        end)
        if ok and animId and animId ~= "" then
            if detectorChargeIds and table.find(detectorChargeIds, animId) then
                return true
            end
        end
    end
    return false
end

-- Public toggle control
local function ControlCharge_SetEnabled(val)
    controlChargeEnabled = val and true or false
    if not controlChargeEnabled and controlChargeActive then
        stopOverride()
    end
end

-- Main loop: check detection each RenderStepped (uses same cadence as noli script)
RunService.RenderStepped:Connect(function()
    if not controlChargeEnabled then
        if controlChargeActive then stopOverride() end
        return
    end

    -- If humanoid dies or character resets, ensure override cleared
    local hum = getHumanoid()
    if not hum then
        if controlChargeActive then stopOverride() end
        return
    end

    local isCharging = detectChargeAnimation()

    if isCharging then
        if not controlChargeActive then
            startOverride()
        end
    else
        if controlChargeActive then
            stopOverride()
        end
    end
end)

-- Keep humanoid state fresh on CharacterAdded
lp.CharacterAdded:Connect(function(char)
    -- small wait to let Humanoid exist
    task.spawn(function()
        local hum = char:WaitForChild("Humanoid", 2)
        if hum then
            -- optionally prime saved state (not necessary)
        end
    end)
end)

lp.CharacterAdded:Connect(function()
    if connection then
        connection:Disconnect()
        connection = nil
    end
end)
